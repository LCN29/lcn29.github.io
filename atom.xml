<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lcn的博客</title>
  
  <subtitle>学无止境</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lcn29.github.io/"/>
  <updated>2019-08-20T07:26:52.273Z</updated>
  <id>http://lcn29.github.io/</id>
  
  <author>
    <name>lcn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashSet</title>
    <link href="http://lcn29.github.io/2019/08/20/HashSet/"/>
    <id>http://lcn29.github.io/2019/08/20/HashSet/</id>
    <published>2019-08-20T07:25:01.000Z</published>
    <updated>2019-08-20T07:26:52.273Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 08:41:09 GMT+0800 (GMT+08:00) --><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>HashSet 内部是通过 HashMap 实现的，所以了解HashSet, 之前应该有一点 HashMap 的知识的, 可以简单的看一下<a href="/2019/08/20/HashMap/">这个</a>。</p><ul><li>创建<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 用 HashMap 存放数据， 其中key就是我们的map的key</span></span><br><span class="line"><span class="comment"> * value 统一为下面的PRESENT</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map中键对应的value值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接放入一个 Collection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">   map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">   addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定容量 和 负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法, 基本可以看作抛弃的方法</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放入全部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c)</span><br><span class="line">            <span class="keyword">if</span> (add(e))</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把数据存到 map 的key中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过上面的代码, 我们可以发现:<br>HashSet是基于HashMap实现的, 我们存入的值，作为map的key, 而value都是统一为一个Object对象 PRESENT</p><ul><li><p>增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把对象当做key, 调用hashMap 的 put方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把对象当做key, 调用hashMap 的 remove方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查<br>Set 比较特殊, 没有提供直接获取值的方法 get(),同时也没必要, 如果你有一个值 a, Set.get(参数), 这个参数填什么? 你是期望从Set中获取到 a 吗？, 如果单纯的是想判断已对象是否存在，可以通过 contain 进行判断。</p></li></ul><h2 id="HashSet-的补充"><a href="#HashSet-的补充" class="headerlink" title="HashSet 的补充"></a>HashSet 的补充</h2><p>1) 因为 HashSet 是通过 HashMap 实现的, HashMap 的 key 可以存null, 但是只能存一个, 所以 HashSet 支持存null, 同时只能存一个<br>2）因为 HashMap 是非线程安全的，所以 HashSet 也是线程非安全的。<br>3）HashSet 也是自定义了序列化方法<br>4) HashSet 内部没有提供自己的迭代器, 他内部是通过 HashMap 的 key迭代器实现的<br>5）HashMap 支持 fail-fast 机制, 理所当然的 HashSet 也是。<br>6）HashSet 的数据是无序的</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 08:41:09 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;HashSet&quot;&gt;&lt;a href=&quot;#HashSet&quot; class=&quot;headerlink&quot; title=&quot;HashSet&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://lcn29.github.io/categories/Java/"/>
    
      <category term="Collection" scheme="http://lcn29.github.io/categories/Java/Collection/"/>
    
    
      <category term="Java" scheme="http://lcn29.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://lcn29.github.io/2019/08/20/HashMap/"/>
    <id>http://lcn29.github.io/2019/08/20/HashMap/</id>
    <published>2019-08-20T07:18:17.000Z</published>
    <updated>2019-08-20T07:19:55.813Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 08:41:09 GMT+0800 (GMT+08:00) --><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>JDK1.8 对 HashMap 进行了比较大的优化, 底层实现由之前的 “数组 + 链表” 改为 “数组 + 链表 + 红黑树”。 在链表的长度大于等于8并且数组的长度大于等于64时,将这个链表转为红黑树<br>所以在继续下去之前, 先确保一下, 你对红黑树(本质是一颗二叉排序树)有一点的了解。 可以看一下这几篇文章, 做一下入门。</p><blockquote><ol><li><a href="https://www.cnblogs.com/tiancai/p/9072813.html" target="_blank" rel="noopener">清晰理解红黑树的演变—红黑的含义</a> 红黑树的前身</li><li><a href="https://blog.csdn.net/v_JULY_v/article/details/6105630" target="_blank" rel="noopener">教你初步了解红黑树</a> 红黑树的节点插入</li><li><a href="https://www.cnblogs.com/qingergege/p/7351659.html" target="_blank" rel="noopener">红黑树之删除节点</a> 红黑树的节点删除</li><li><a href="https://my.oschina.net/u/3272058/blog/1914452" target="_blank" rel="noopener">红黑树原理以及插入、删除算法 附图例说明</a> 里面的增删图片不错</li></ol></blockquote><p>上面几篇文章是我在学习红黑树是看的, 感觉质量挺不错的，起码我是看懂了。 当然如果你已经都红黑树有一定的了解了，那么我们直接开始吧。</p><p>入门前介绍一下</p><ol><li><p>在 HashMap 中, 一开始存储数据的数组的类型是链表，链表的声明如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的hash</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点的 key</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点的 value</span></span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下一个节点</span></span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Objects.hashCode 本质就是调用对象的 o.hashCode()</span></span><br><span class="line">        <span class="comment">// 当前节点的hashCode 值 是   key的hashCode  异或 value的hashCode 值</span></span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 节点比较</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="comment">// Objects.equals 会 先比较一下 2者的内存地址， 一样直接返回true</span></span><br><span class="line">                <span class="comment">// 不一样，调用 key.equals(e.getKey) 进行比较</span></span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 HashMap 中, 一开始存储数据的数组的类型是链表，在一定情况下, 会转为红黑树, 定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了 LinkedHashMap.Entry, Entry 继承了 HashMap.Node  所以 TreeNode 具有 链表的特点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 后面 省略 红黑树的操作</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>HashMap的创建<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -Djava.lang.Integer.IntegerCache.high=250 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 最大的容量 2^30  既 01 + 30个0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子： 默认为0.75</span></span><br><span class="line"><span class="comment">// 作用： 在ArrayList 中 通常都是在数组满了才会进行扩容, 但是在HashMap中, 数据量达到了数组的长度 * 负载因子的值，就进行扩容</span></span><br><span class="line"><span class="comment">// 原因： hashMap 在数组中插入一个数据，是先通过一个hash方法转为到数组的一个位置, 通过Hash就可能存在hash冲突, </span></span><br><span class="line">    <span class="comment">// 数据越密集，冲突的可能性越大, 所以 hashMap 中的数组是不会完成存满的, 通过空留一部分, 减少冲突等</span></span><br><span class="line"><span class="comment">// 负载因子 默认值为 0.75 的原因： 太多的话，冲突可能性变大，太小浪费了空间，同时会导致数组扩容等耗时操作, 所以 0.75 应该是一个经验值的估算, </span></span><br><span class="line"><span class="comment">// 或者 是因为 HashMap的数组长度为 2^n, 乘以 0.75, 能获得一个整数吧</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来当前数组的阈值, 实际应该放多少数据,</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放数据的地方</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 无参的构造函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置了负载因子为默认值： 0.75, 其他的属性默认</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定容量的初始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 指定初始容量 和 负载因子  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式不正确</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式不正确  isNaN(arg) =&gt; arg 不是数字，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// 此次的阈值 为 2的n次方, 实际应该是 2^n * 负载因子, 这里会在你第一次放数据时，进行修正，只是这里刚刚用它来存数组实际需要的容量</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定 Map的的创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算负载，也就是数组当前的容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此次减1的原因时，让后面基本处理处理的结果变为 n是第一个大于等于cap的 2的n次方的数</span></span><br><span class="line">    <span class="comment">// 如果这里不减 1 的话， 我们刚好传进来的数是 2的n次方, 经过下面几步的处理会变成 2的n+1次方</span></span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// 做一个容错 如果 cap 是一个 大于 2^31 的正数, 经过上面的处理, 次数 n会变为负数</span></span><br><span class="line">        <span class="comment">// n为负数了，直接设置为1</span></span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放入数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m 数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前存放数据的 table 为空</span></span><br><span class="line">            <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算出来需要的容量 =   长度 / 赋值因子 + 1</span></span><br><span class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="comment">// 限制最大的容量 为  2^ 31</span></span><br><span class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ? (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算出来的当前需要的容量 &gt; 实际的容量，进行新容量的计算</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            <span class="comment">// 当前存入的数据量 直接大于当前阈值，进行重新扩容</span></span><br><span class="line">                resize();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">                K key = e.getKey();</span><br><span class="line">                V value = e.getValue();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存值</span></span><br><span class="line"><span class="comment">     * @ hash 存的可以的hash值</span></span><br><span class="line"><span class="comment">     * @ key  对象的key</span></span><br><span class="line"><span class="comment">     * @ value 存的值</span></span><br><span class="line"><span class="comment">     * @ onlyIfAbsent 存入的节点已在hashMap中存在， 是否有新的value替代 旧的 value false进行修改, true不修改</span></span><br><span class="line"><span class="comment">     * @ evict 这个值用于 LinkedHashMap 在HashMap 中没有作用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">// 数组为空 或者 数组的长度为 0, 进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// hashMap 对象的位置 是通过  (数组的长度 - 1) &amp; hash, 也就是 hash % 2 ^ n</span></span><br><span class="line">        <span class="comment">// 指定为位置为空，直接将他放到指定的位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 需要放入的位置的第一个节点 的 hash 和 key 一样，取到这个节点</span></span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">e = p;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="comment">// 调用红黑树 进行处理</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="comment">// 从链表的第一个节点开始遍历到尾部</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一个节点为空, 直接将当前的节点放到尾部</span></span><br><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 当前的容量 已经达到了 8个, 转为 红黑树, 这个方法这里没有介绍</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链表中有一个节点的hash 和 key 和要插入的一样，取到这个节点</span></span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">p = e;</span><br><span class="line">&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">V oldValue = e.value;</span><br><span class="line"><span class="comment">// 新值 替换旧值</span></span><br><span class="line"><span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">// HashMap的这个方法 没有实现</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用于支持 fast-fail 机制</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// 达到了阈值，进行扩容</span></span><br><span class="line">            <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line"><span class="comment">// HashMap的这个方法 没有实现</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算对象的hash值 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">// 对象的hashCode ^ 对象的hashCode &gt;&gt;&gt; 16</span></span><br><span class="line">        <span class="comment">// 将hashCode的高16位与hashCode进行异或运算，主要是为了在table的length较小的时候，让高位也参与运算，并且不会有太大的开销</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重新扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前的容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">// 当前的阈值</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">// 新的容量，新的阈值</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前的容量不为0, 也就是有数据存在了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前的容量已经达到最大了，直接不进行操作</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 直接将阈值设为int 的最大值</span></span><br><span class="line">            <span class="comment">// 实际的数组长度为 2^30  现在直接把阈值变为了 (2^31 - 1), 应该是为了能够利用还剩余的空间吧 </span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            <span class="comment">// 新的容量 = 旧的容量 * 2     新的容量 &lt; 最大容量 &amp;&amp; 旧的容量 &gt;= 初始默认的容量(16) 直接设置新的负载 = 旧的 * 2</span></span><br><span class="line">            <span class="comment">// oldCap &gt;= DEFAULT_INITIAL_CAPACITY 的 作用 看下面的 备注1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 当旧的阈值大于 0, 设置 新的容量 = 阈值</span></span><br><span class="line">            <span class="comment">// 能够走到这一步的情况有： </span></span><br><span class="line">            <span class="comment">// 1. 我们初始时，只指定了容量， 然后第一次往里面加数据</span></span><br><span class="line">            <span class="comment">// 2. 初始时, 只传递了一个Map, 然后第一次把Map里面的数据放到当前HashMap时</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 当我们创建时, 没有指定容量时, 在第一次放数据，会走这一步进行容量的设置 默认时 16, 阈值为 16 * 0.75</span></span><br><span class="line">            <span class="comment">// 能够走到这一步的情况有：</span></span><br><span class="line">            <span class="comment">// 我们初始时, 没有指定任何参数</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算 阈值 = 新容量 * 0.75, 如果 阈值超过了最大容量, 则直接设置为 int的最大值</span></span><br><span class="line">            <span class="comment">// 能够走到这一步的情况有：</span></span><br><span class="line">            <span class="comment">// 1. 我们初始时，只指定了容量， 然后第一次往里面加数据</span></span><br><span class="line">            <span class="comment">// 2. 初始时, 只传递了一个Map, 然后第一次把Map里面的数据放到当前HashMap时</span></span><br><span class="line">            <span class="comment">// 3. 扩容时, 新的容量 &lt; 32  这一种情况，需要结合上面的扩容的 oldCap &gt;= DEFAULT_INITIAL_CAPACITY 进行分析</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置新的阈值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line"></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">// 数组 重新赋值</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">// 获取到当前数组的第 j个元素</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 旧的值设置为空, 方便垃圾回收</span></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">// 如果e.next为空, 则代表旧数组的该位置只有1个节点, 那么把这个节点直接放到新数组里面，就行了</span></span><br><span class="line">                        <span class="comment">// 通过 (节点 的 hash 值 &amp; 新容量 -1 ) 取到新的位置</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">// 原本的这个节点为 树节点, 调用TreeNode的split进行处理</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 声明了2个链表 lo链表, hi链表, 同时声明了4个指针, 分别指向了2个链表的头和尾 </span></span><br><span class="line">                    <span class="comment">// 其中的 lo 可以理解为 low, hi 为 hight, 新的数组 是原来的2倍， 那么 原来的一倍 可以理解为 low, 扩充出来的为 hight</span></span><br><span class="line">                    <span class="comment">// 而原本在同一个链表上的节点, 在后面的扩容， 会被分配到2个地方   和原来一样的index, 或者 index + oldCap</span></span><br><span class="line">                    <span class="comment">// lo链表 存放的是 节点位置不需要修改的节点</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       <span class="comment">// hi链表 存放的是 节点位置需要修改的节点， 这里的位置变为了 index + oldCap, </span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">// 下一个节点</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">// 这一步的判断： 判断节点在新数组的位置是否和在旧数组的一样 等于0 表示一样。</span></span><br><span class="line">                            <span class="comment">// 原理看一下 备注2</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    <span class="comment">// 如果loTail为空, 代表该节点为第一个节点</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">// 否则将节点添加在链表的尾部</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                <span class="comment">// 重新设置尾结点</span></span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="comment">// 作用同上面</span></span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 设置数组的 j位置 为 lo链表</span></span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 设置数组 的 j + oldCap 为 hi链表</span></span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的位置转为树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">// 数组为空， 长度还不够 64, 进行扩容, 不进行转换操作</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 需要处理的位置的链表不为null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 因为 TreeNode 继承了 Node, 所以 TreeNode 也可以当做链表使用</span></span><br><span class="line">            <span class="comment">// 将Node 转为 TreeNode</span></span><br><span class="line">            <span class="comment">// 然后将下面拼接成 一个以 TreeNode 为类型的 链表</span></span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 树的根节点</span></span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 按照链表的格式, 改变节点的指向, </span></span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 重新将当前节点头结点设置为 树的根节点</span></span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 转为树</span></span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>备注 1:<br>在 resize方法中, 旧数组已有数据了, 但是在进行扩容时, 容量默认是2倍扩展，但是阈值只有在 <code>oldCap &gt;= DEFAULT_INITIAL_CAPACITY</code> 时才会进行2倍扩展, 否则是以 新的容量 * 负载因子, 原因：为了在容量少的情况下，尽可能的利用数组的空间，不造成浪费。<br>假设我们在初始时，指定了容量为2, 那么在初始后 容量值为 2, 阈值为 * 0.75 = 1。</p><p>第一次扩容：<br>| | 旧的容量 |新的容量 |旧的阈值| 经过运算新的阈值 |<br>| :-: | :-: | :-: | :-: | :-: |<br>| 旧阈值 &lt;&lt; 1 | 2 | 4 | 1 | 2 |<br>| 新容量 × 0.75 | 2 | 4 | 1 | 3 |</p><p>第一次扩容：<br>| | 旧的容量 |新的容量 |旧的阈值| 经过运算新的阈值 |<br>| :-: | :-: | :-: | :-: | :-: |<br>| 旧阈值 &lt;&lt; 1 | 4 | 8 | 2 | 4 |<br>| 新容量 × 0.75 | 4 | 8 | 3 | 6 |</p><p>第三次扩容<br>| | 旧的容量 |新的容量 |旧的阈值| 经过运算新的阈值 |<br>| :-: | :-: | :-: | :-: | :-: |<br>| 旧阈值 &lt;&lt; 1 | 8 | 16 | 4 | 8 |<br>| 新容量 × 0.75 | 8 | 16 | 6 | 12 |</p><p>第四次扩容<br>| | 旧的容量 |新的容量 |旧的阈值| 经过运算新的阈值 |<br>| :-: | :-: | :-: | :-: | :-: |<br>| 旧阈值 &lt;&lt; 1 | 16 | 32 | 8 | 16 |<br>| 新容量 × 0.75 | 16 | 32 | 12 | 24 |</p><p>通过上面可以发现：在旧容量 &lt; 16 之间变化时, 通过 新容量 × 负载因子, 阈值会大一些, 可以更充分的理由数组的空间, 在第四次扩容时, 旧的阈值为12, 新容量为32时，这时12 &lt;&lt; 1 等于 32 * 0.75, 所以2者后续的计算是一样的，通过位运算比较快。</p><p>备注 2：<br>(e.hash &amp; oldCap) == 0 可以判断节点在新数组的位置和旧数组的是否一样。 能达到这样的效果的必须知道：</p><blockquote><ol><li>oldCap 是 2 ^ n, newCap 是 在 oldCap的基础 * 2, 也就是 newCap 是 2 ^ (n + 1)</li><li>2 ^ n 在二进制的表示为 1 + n个0 , 2 ^ (n + 1) 二进制表示 1 + (n+1)个0</li><li>2 ^ n - 1 在二进制的表示为 n 个 1, 那么 2 ^ (n + 1) 就是 n + 1 个 1</li><li>(2 ^ n - 1) &amp; hash 我们只需要取hash的1到n位就行了, 因为 2 ^ n - 1 前面都是 0</li></ol></blockquote><p>1) 我们假设 现在 oldCap是16,既 2^4, 16 - 1 = 15, 二进制表示为 00000000 00000000 00000000 00001111<br>2) (16-1) &amp; hash 自然就是取hash值的低4位, 我们假设它为 abcd<br>3) oldCap扩大了一倍, 新的index的位置就变成了 (32-1) &amp; hash, 就是取 hash值的低5位, 那么对于同一个Node, 低5位的值无外乎下面两种情况: <code>0abcd</code> 或者 <code>1abcd</code><br>4）0abcd = index, 而 1abcd = 0abcd + 10000 = 0abcd + oldCap = index + oldCap, 从这里可以知道 容量扩大了一倍, 那么 新的index是有规律的, 要么不变, 要么就是 index + oldCap<br>5) 新旧index是否一致就体现在hash值的第5位, 那么第5位怎么知道呢？ 这时我们可以知道 2^n 的二进制形式 1 + 5个0, 那么 hash &amp; oldCap 就能知道 hash 的第5位 是0 或者 1<br>6） hash &amp; oldCap = 0 =&gt; 当前节点在数组的位置不用变, hash &amp; oldCap != 0 =&gt; 当前节点在新数组的 index + oldCap 的位置</p><ul><li><p>查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 key 获取value, 如果 节点为null, 返回nulL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过key的 hash 和 key 获取对应的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组不为空，长度大于 0 ， 链表的第一个节点 不为 null</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一个节点 符合条件了, 直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp;  ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 树节点</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 遍历 链表的其他节点,</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没找到 直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存入新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 查看上面的 putVal方法</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接通过 key删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  通过key 和 内容 进行删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * matchValue : 为 true，找到了节点，还会比较他们的值，值相同才会删除</span></span><br><span class="line"><span class="comment">     * movable : 为false, 蛋节点删除了, 不改变其他节点的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组不为null, 长度大于 0，同时定位到的位置 不为 null</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">// 链表的第一个节点，的情况符合了</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="comment">// 链表的下一个节点不为null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 节点为 树节点</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遍历链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 寻找找到符合条件</span></span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到了需要的节点  如果设置了需要检查值, 后面会对其值的内存地址和equals进行比较 </span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 调用红黑树的删除节点的方法</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                <span class="comment">// 把 链表的头部直接指向了下一个节点</span></span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// p的下一个节点指向需要删除节点的下一个节点</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line"></span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>HashMap的总结</p><blockquote><ol><li>HashMap 中的数组都是2的幂次方, 最大上限为 2^30</li><li>每个存到HashMap中的 key, value 都会被封装到为 Node, Node 里面有一个 hash值, 这个值可以定位到他在数组的位置 (hash &amp; (数组的长度 - 1), 这里相当于 hash % 数组的长度), 同时可以知道他在链表或者树中的位置, 这个值的计算<br><code>(key = key.hashCode()) ^ (key &gt;&gt;&gt; 16)</code></li><li>HashMap 中链表向红黑树的转换 的时机： 数组的长度大于等于 64, 同时 链表的长度 &gt;= 8</li><li>HashMap 中红黑树可以转换为链表, 时机： 红黑树中的节点数小于等于 6, 会由 红黑树转为链表, 具体代码可以看一下 HashMap.TreeNode.split</li><li>HashMap 中的阈值在 当前容量 小于32, 都是等于 当前容量 * 负载因子, 大于等于32, 等于12(当容量为16时, 16 * 负载因子, 默认0.75) * 2</li><li>通过对put 的分析，我们可以知道, HashMap.put(null, value) 是可以的, 此时key的hashCode为0, 但是key值需要唯一，所以HashMap, 只能存一个key为 null 的值,</li><li>HashMap 默认的初始容量为 16, 负载因子为 0.75, 其中指定的容量不是2的n次方的话，会转换为大于等于这个值的2的n次方, 还有负载因子如果没有必要，尽量不要去修改</li><li>get的过程<blockquote><ol><li>通过key 获取到对应的hashCode <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></li><li>同hashCode &amp; 数组的长度, 得到他在数组中的位置</li><li>遍历对应位置的链表或者树, 通过 <code>e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))</code> 进行比较, 如果为true, 就一样的。</li><li>依次比较的内容, 2个key 的hashCode 一定要一样</li><li>hashCode 一样了, 如果内存地址一样, 那么一样</li><li>hashCode 一样了，内存地址不一样, 在通过 equals 比较一次, (正常情况下这个是直接调用Object.eqhals方法, 还是比较的是2个对象的内存地址, 但是如果你重新了,那么就用你重新的方法)</li></ol></blockquote></li></ol></blockquote><p>HashMap的补充</p><blockquote><ol><li>HashMap 同样是线程不安全的, 如果需要线程安全，同样可以通过 Collections.synchronizedMap() 获取到一个线程安全的实现类。</li><li>HashMap 支持 fail-fast机制</li><li>HashMap 的序列化也是自定义的</li><li>HashMap 内部提供了许多迭代器: KeyIterator, ValueIterator, EntryIterator</li><li>HashMap 的线程不安全, 猜测时, 同时有2个线程判断到需要扩容了, 然后同时进行扩容, 期间就可能造成闭合的链路。</li></ol></blockquote><hr><p>参考<br><a href="https://blog.csdn.net/v123411739/article/details/78996181" target="_blank" rel="noopener">Java集合：HashMap详解（JDK 1.8）</a><br><a href="https://segmentfault.com/a/1190000015812438?utm_source=tag-newest" target="_blank" rel="noopener">深入理解HashMap(四): 关键源码逐行分析之resize扩容</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 08:41:09 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://lcn29.github.io/categories/Java/"/>
    
      <category term="Collection" scheme="http://lcn29.github.io/categories/Java/Collection/"/>
    
    
      <category term="Java" scheme="http://lcn29.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ArrayDeque</title>
    <link href="http://lcn29.github.io/2019/08/17/ArrayDeque/"/>
    <id>http://lcn29.github.io/2019/08/17/ArrayDeque/</id>
    <published>2019-08-17T06:19:25.000Z</published>
    <updated>2019-08-17T08:20:24.454Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 08:41:08 GMT+0800 (GMT+08:00) --><h1 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h1><h2 id="ArrayDeque-1"><a href="#ArrayDeque-1" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><p>ArrayDeque是一个基于数组实现的双端队列(double-ended-queue)。 Deque接口除了提供操作双端队列的一系列方法之外，还提供了操作栈的方法，因此ArrayDeque也可以表示一个栈。</p><p>基于数组实现队列时, 我们添加数据时, 可以直接在尾部添加了数据，但是如果我们要取数据呢，我们把第一个取出来后，后面的数据都往前移一位, 这是一个很费时的操作。 为了解决这个问题, 我们引入了2个索引, 一个指向了头, 另一个指向了数组有效数据的后一位(第一个空位), 这样我们取的时候, 头部置为空，然后头指针往后移一位。 添加时, 如果尾指针已经到了最后一位, 那么重新到数组的头部查找, 放到头部。 最后通过判断头尾指针是否一样，来决定是否要扩容。</p><p>结构图:<br><img src="https://s2.ax1x.com/2019/08/17/munQ6P.png" alt="Alt &#39;ArrayList&#39;"></p><p>操作方法</p><table><thead><tr><th align="left">offer系列</th><th align="left">add系列</th><th align="left">方法描述</th></tr></thead><tbody><tr><td align="left">offerFirst()</td><td align="left">addFirst()</td><td align="left">将指定的元素插入到队首</td></tr><tr><td align="left">offerLast()</td><td align="left">addLast()</td><td align="left">将指定的元素添加到队尾</td></tr><tr><td align="left">pollFirst()</td><td align="left">removeFirst()</td><td align="left">取出并删除队首的元素</td></tr><tr><td align="left">pollLast()</td><td align="left">removeLast()</td><td align="left">取出并删除队尾的元素</td></tr><tr><td align="left">peekFirst()</td><td align="left">getFirst()</td><td align="left">取出队首的元素，但不删除</td></tr><tr><td align="left">peekLast()</td><td align="left">getLast()</td><td align="left">取出队尾的元素，但不删除</td></tr></tbody></table><p>它们的区别是：offer系列方法在操作失败时会返回一个特殊值（根据操作的不同，为false或者null）；add系列方法在操作失败时会抛出异常。</p><ul><li><p>ArrayDeque的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDeque</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Object[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队首元素的索引</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队尾的下一个索引</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_INITIAL_CAPACITY = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没有指定容量, 默认为2^4 16</span></span><br><span class="line">        <span class="comment">// arrayDeque 的容量设置为都是2的n次方, 是为了方便后续的操作</span></span><br><span class="line">        elements = <span class="keyword">new</span> Object[<span class="number">16</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指定了大小, 会根据你传入的值, 扩大到第一个大于你传入的值的2的n次方</span></span><br><span class="line">        allocateElements(numElements);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传递集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据 出入的 Collection的大小，进行扩容</span></span><br><span class="line">        allocateElements(c.size());</span><br><span class="line">        <span class="comment">// 添加c到数组中</span></span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[calculateSize(numElements)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateSize</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// MIN_INITIAL_CAPACITY = 8;</span></span><br><span class="line">        <span class="comment">// 从这里可以看出 ArrayDeque的最小容量 为8</span></span><br><span class="line">        <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">            initialCapacity = numElements;</span><br><span class="line">            <span class="comment">// &gt;&gt;&gt; 无符号 右移 =&gt; 右移后，最高位直接取0</span></span><br><span class="line">            <span class="comment">// 经过下面的6步  可以将 initialCapacity 变成 第一个大于 numElements的2的n次方</span></span><br><span class="line">            <span class="comment">// 要理解下面的算法，有一点认识：</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一： 2^n   二进制的形式为: 从1到n位 都是0, 第n+1位为1</span></span><br><span class="line">            <span class="comment">// 如 (int)256  2^8  =&gt; 00000000 00000000 00000001 00000000</span></span><br><span class="line">            <span class="comment">// 第二： 那么 2^n - 1 就能推出  =&gt; 从1到n-1位 都是1  第n位为0, </span></span><br><span class="line">            <span class="comment">// 255 =&gt; 00000000 00000000 00000000 11111111</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设 initialCapacity 转为2进制后, 有效的位算为x位, </span></span><br><span class="line">            <span class="comment">//既从右往左算到最后一个1的长度, 如上面的 256, x就是9, 255, x就是8</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一步: initialCapacity二进制 表示 =&gt; 1 + (x-1 个 0/1),   </span></span><br><span class="line">            <span class="comment">// initialCapacity &gt;&gt;&gt; 1  =&gt; 01 + (x-2 个 0/1), </span></span><br><span class="line">            <span class="comment">//或(|)运算后 =&gt; 11(x-2 个 0/1) =&gt; initialCapacity的有效位的前2位都为1了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二步: initialCapacity =&gt; 11(x-2 个 0/1),  </span></span><br><span class="line">            <span class="comment">// initialCapacity &gt;&gt;&gt; 2 =&gt; 0011(x-4 个 0/1), |运算后 =&gt; 1111（x-4 个 0/1）=&gt; 前4位都为1了</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 经过了前 5 步  initialCapacity 变成了 1(x-1 个 1) </span></span><br><span class="line">            <span class="comment">// 第6步 + 1   initialCapacity 变成了 1(x个0)  也就是变成了 2 ^ initialCapacity的有效位 也就是变成了 2^n</span></span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">            initialCapacity++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 做一个容错, 如果 numElements很大的时候，经过位运算 会变成负的</span></span><br><span class="line">            <span class="comment">// 可以推导出 numElements的值 &gt;= 2^30 时, 就会变为负</span></span><br><span class="line">            <span class="comment">// 2^30 的二进制 =&gt; 01000000 00000000 00000000 00000000 (int的长度为32位)  </span></span><br><span class="line">            <span class="comment">// 经过上面的 上面的前 5步   initialCapacity=&gt;  01111111 11111111 11111111 11111111</span></span><br><span class="line">            <span class="comment">// 在经过 第 6步,  initialCapacity=&gt;  10000000 00000000 00000000 00000000 =&gt; -2147483648 变成了负了</span></span><br><span class="line">            <span class="comment">// 这时在将 initialCapacity 右移1位，转为正的 initialCapacity &gt;&gt;&gt;= 1 =&gt; 01000000 00000000 00000000 00000000</span></span><br><span class="line">            <span class="comment">// 最终可以得出 ArrayDeque 的最大容量为 1073741824   2^31</span></span><br><span class="line">            <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) </span><br><span class="line">                <span class="comment">// 最大的容量 2^30个 元素</span></span><br><span class="line">                initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> initialCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 使用的是父类 AbstractCollection的addAll方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c)</span><br><span class="line">            <span class="keyword">if</span> (add(e))</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素 默认添加到后面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素添加到最后面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ArrayDeque不允许放入null</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 添加到后面</span></span><br><span class="line">        elements[tail] = e;</span><br><span class="line">        <span class="comment">// 尾部指针往后 + 1  判断是否需要扩容   </span></span><br><span class="line">        <span class="comment">// 下面的 a &amp; (b -1)  当 b为 2^n, 同时 a &gt; 0 的情况下   a&amp;(b-1) 效果等同于 a%b(取模)</span></span><br><span class="line">        <span class="comment">// 头和尾指针一样, 容量满了， 进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">            doubleCapacity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> head == tail;</span><br><span class="line">        <span class="keyword">int</span> p = head;</span><br><span class="line">        <span class="keyword">int</span> n = elements.length;</span><br><span class="line">        <span class="comment">// 头指针右边的数量</span></span><br><span class="line">        <span class="keyword">int</span> r = n - p;</span><br><span class="line">        <span class="comment">// 扩容 变为原来的2倍</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);</span><br><span class="line">        Object[] a = <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">        <span class="comment">// 把原本的右边的放到a的开始位置</span></span><br><span class="line">        System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">        <span class="comment">// 把左边的放到了 a 的r的位置</span></span><br><span class="line">        System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">        elements = a;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放到头部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放到头部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// head的取值 [0, elements.length - 1],  head - 1 =&gt; [-1, elements.length - 2], </span></span><br><span class="line">    <span class="comment">// 如果 head为 -1， 二进制为 11111111 11111111 11111111 11111111</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这样, 当 head -1 为 -1时，通过 &amp; 得到的值 就是elements.length - 1, 回到了数组的最后的一位了。</span></span><br><span class="line">    <span class="comment">// 当 head -1 &gt;= 0, 那么就是 相当于取模, 同时 head 一定不会大于 elements.length, </span></span><br><span class="line">    <span class="comment">// 所以 结果就是 head - 1的值, 也就是让head前进一位，</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所以下面的方法, 使得  head = 0 时， head = elements.lenght    head &gt;0, head = head -1;</span></span><br><span class="line">    <span class="comment">// 最终 形成了一个循环</span></span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 追加到后面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 看上面的构造方法</span></span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取出并删除队首的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> h = head;</span><br><span class="line">    E result = (E) elements[h];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    elements[h] = <span class="keyword">null</span>; </span><br><span class="line">    <span class="comment">// 此次相当于取模 (h + 1) % elements.lenght  当 h已经是队尾了，可以回到头部</span></span><br><span class="line">    head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取出并删除队首元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此次的原理 同 addFirst()</span></span><br><span class="line">    <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    E result = (E) elements[t];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    elements[t] = <span class="keyword">null</span>;</span><br><span class="line">    tail = t;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取出队首的元素，但不删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elements[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取出队尾的元素，但不删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为默认 tail 不是指向 尾元素，而是尾元素的后一个元素, 所以需要计算一下</span></span><br><span class="line">    <span class="keyword">return</span> (E) elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li>ArrayDeque 是一个线程不安全的集合</li><li>ArrayDeque 不允许存放null元素</li><li>ArrayDeque 不仅可以作为双端队列使用，还可以当做栈使用, 官方也是推荐的，里面还提供对应的操作 <code>push</code>, <code>pop</code></li><li>ArrayDeque 也是自己重写了序列化和发序列化方法</li><li>ArrayDeque 当用作栈时，性能优于Stack，当用于队列时，性能优于LinkedList</li><li>ArrayDeque 也是支持fail-fast机制, 内部自己实现了Iterator接口, 当是他用的不是modCount, 而是自身的指针tail，每次遍历时判断当前的tail是否修改过了，是的话直接扔 <code>ConcurrentModificationException</code></li><li>ArrayDeque 内部还实现了一个 DescendingIterator 的迭代器，可以用于从尾部遍历到头部</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 08:41:08 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;ArrayDeque&quot;&gt;&lt;a href=&quot;#ArrayDeque&quot; class=&quot;headerlink&quot; title=&quot;ArrayDe
      
    
    </summary>
    
      <category term="Java" scheme="http://lcn29.github.io/categories/Java/"/>
    
      <category term="Collection" scheme="http://lcn29.github.io/categories/Java/Collection/"/>
    
    
      <category term="Java" scheme="http://lcn29.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList</title>
    <link href="http://lcn29.github.io/2019/08/17/LinkedList/"/>
    <id>http://lcn29.github.io/2019/08/17/LinkedList/</id>
    <published>2019-08-17T05:55:09.000Z</published>
    <updated>2019-08-17T08:13:39.726Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 08:41:09 GMT+0800 (GMT+08:00) --><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>LinkedList 是基于 双向链表实现的。</p><blockquote><ol><li>单链表, 双链表, 循环链表的定义, 可以看一下<a href="https://www.jianshu.com/p/6ebedde370b0" target="_blank" rel="noopener">这个</a></li><li>链表内存是散乱的, 每一个元素存储本身内存地址的同时还存储下一个元素的地址</li><li>链表具备了增删快, 查找慢的特点</li><li>LinkedList 是基于双向链表设计的, 所以具备了链表的特点</li></ol></blockquote><h2 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>结构图:<br><img src="https://s2.ax1x.com/2019/08/13/m9e94s.png" alt="Alt &#39;ArrayList&#39;"></p><ul><li>LinkedList的创建<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前的数据个数 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/** Node是LinkedList的一个内部类  第一个节点 */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** 最后一个节点 */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LinkedList 内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前节点的内容 */</span></span><br><span class="line">        E item;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/** 下一个节点 */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 上一个节点 */</span></span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定集合创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从指定位置, 批量添加元素</span></span><br><span class="line"><span class="comment">     * 下面的方法可以分成这几个</span></span><br><span class="line"><span class="comment">     * 1. 当前的数据都为null, 那次c中的第一个数据，封装成node, node的pre为空, 将LinkedList的first设置为这个node, 后面的数据依次拼在node的后面</span></span><br><span class="line"><span class="comment">     * 2. 已有数据，新增的数据追加在已有数据的最后面, 直接拼在最后就行了</span></span><br><span class="line"><span class="comment">     * 3，已有数据，新增数据插在已有的中间,  把已有数据安装需要插入的位置分成2部分， A, B, 把新增的数据 先拼到A的后面， 然后把B在拼到新的A的后面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pred: 新增的元素的将要插入的位置的前一个节点  succ: 新增的元素的将要插入的位置的节点</span></span><br><span class="line">        <span class="comment">// 假设 新增的元素的位置为a, 那么 pred 就是 a的前一位的节点, succ 就是a节点</span></span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要添加的元素刚好追加在已有的后面的</span></span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            succ = <span class="keyword">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在已有数据的中间插入</span></span><br><span class="line">        <span class="comment">// 如果 当前的site 为10，当时我们传递的 index为15, 则会在是最后的一个元素也就是10 后面追加</span></span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            E e = (E) o;</span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 第一次创建时, 那么第一个节点就是 first节点</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 将 pred的下一个节点向下新创建的节点</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            <span class="comment">// 将 pred 改为当前节点，方便下一个元素操作</span></span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接在已有的数据后面追加元素的话, succ是为空的, 所以将最后节点设置为新增元素的最后一个元素的节点</span></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在中间新增的话, 经过上面的处理后, 已有的数据前部分已经和新增的数据连接在已经了, 下面的处理 已有数据的后面部分，将其拼接到新的链表的后面</span></span><br><span class="line">        <span class="comment">// pred 当前为新的链表的最后节点了, 将他指向了原有数据后半部分的第一个节点</span></span><br><span class="line">            pred.next = succ;</span><br><span class="line">            <span class="comment">// 原有数据后半部分的第一个节点的前一个节点 设置为新的链表的最后节点了</span></span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前的长度</span></span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="comment">// 修改次数加1 </span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作的位置是否合法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定的位置 是否合法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到需要的位置的当前的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此次做了一个小优化， 当要查找的位置 小于 现有数据的一半, 从前往后找, 大于的话, 从后面开始找</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="comment">// 如果 当前的site 为10， 当时我们传递的 index为15, 则会在是最后的一个元素后面追加</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从代码可知</p><blockquote><ol><li>LinkedList是基于双向链表实现了</li><li>LinkedList的数据 是通过 first(节点) 和 last(节点) 和 size 三个共同维护的</li><li>LinkedList内部的数据通过泛型，维持了自己的类型, 没有转为 Object。</li><li>LinkedList的无参构造函数，没有执行任何操作</li></ol></blockquote><ul><li>LinkedList的添加元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素，默认添加到最后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定位置添加元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到头部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到尾部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 这个方法在 创建时讲过了 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到最后面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 声明一个变量 临时存储 当前的最后一个元素</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 将插入的元素封装为node, 并且将他的前街道设置为 last</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 将LinkedList的最后一个元素设置为新的元素</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果一开始的最后一个元素就是为null, 也就是没有第一次往LinkedList放入元素，将first元素设置为当前元素</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 否则 设置一开始的最后一个元素的下一个节点为当前的新节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到最前面(大体和linkLast类似)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将某个元素存到某个节点的前面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// pred 为指定节点的前置节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 将元素封装为Node, 同时设置一个节点的前置节点为 需要插入节点的前置节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// 将被插入的节点的前置节点设置为新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 如果插入的节点刚好为第一个节点，那么将新的节点更新为前置节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 设置前置节点的后一个劲节点为新的节点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从代码中, 我们可以指定往LinkedList中添加数据的过程</p><blockquote><ol><li>不需要确定LInkedList的容量, 也就不需要扩容等操作, 数据量也没有上限</li><li>每次新增时, 只需要把涉及到的节点的前置节点, 后置修改了就行了</li><li>指定位置的插入, 也就比插入到最后的情况, 多修改了一个后置节点的指向</li></ol></blockquote><ul><li>LinkedList的删除元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不指定参数, 默认删除第一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除 第一个, 后面还有 removeLast，类似的不做解释了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定位置的异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 检测移除的位置是否正确</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 通过遍历所有节点，找到需要删除的节点, 然后调用 unlink() 进行删除，这里就不做解释了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除元素是第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">// 找到第一个元素的下一个元素</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将第一个元素设置为 next</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">// 如果原本第一个元素就是没有后续元素时，将最后的元素设置为null</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 将 新的第一个元素的前置节点设置为null</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定位置的移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="comment">// 得到将要移除的元素的后置节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">// 得到将要移除的元素的前置节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前置节点为空, 说明移除的为头节点, 重新设置头节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将前置节点的下一个节点设置为后置节点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果后置节点为空, 说明移除的为为节点, 重新设置为节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将后置节点的前置节点设置为前置节点</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从代码中, 我们可以从LinkedList中删除数据的过程</p><blockquote><ol><li>找到需要删除的节点</li><li>找到节点的前置节点和后置节点</li><li>修改前置节点的后一个节点为后置节点， 把后置节点的前一个节点设置为前置节点</li></ol></blockquote><h2 id="LinkedList补充"><a href="#LinkedList补充" class="headerlink" title="LinkedList补充"></a>LinkedList补充</h2><blockquote><ol><li>LinkedList 实现了 Serializable 接口, 但是他的节点都是设置为 transient？</li></ol></blockquote><p>LinkedList重写了 序列化方法 <code>writeObject</code> 和 发序列化方法 <code>readObject</code>, 在序列化中, 重新通过遍历所有节点，把所有节点数据写入到 ObjectOutputStream 。</p><blockquote><ol start="2"><li>LinkedList 也是继承至 List, 也有 <code>modCount</code> 的操作, 也就是 LinkedList 也是支持 fail-fast机制</li></ol></blockquote><blockquote><ol start="3"><li>LinkedList不是一个线程安全的集合？</li></ol></blockquote><p>LinkedList是线程不安全的, 如果需要保证线程的安全性, 可以考虑使用 Collections.synchronizedList(Lise l) 函数返回一个线程安全的LinkedList类</p><blockquote><ol start="4"><li>不要用 for 遍历 LinkedList</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"1"</span>);</span><br><span class="line">list.add(<span class="string">"2"</span>);</span><br><span class="line">list.add(<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.size(); i++) &#123;</span><br><span class="line">String item = list2.get(i);</span><br><span class="line">System.out.println(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedList的源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上: 我们通过 for 遍历 LinkedList，我们通过 get(1)时，就是我们需要 first -&gt; node1, 循环到 get(2)时, 又从 first -&gt; node1 -&gt; node2 找, 所以每次get() 都是从第一个节点一直往下找到, 需要的节点为止。 所以遍历 LinkedList可以使用 foreach（foreach循环的原理就是迭代器) 或者 迭代器</p><blockquote><ol start="5"><li>LinkedList h还有其他作用吗</li></ol></blockquote><p>LinkedList 实现了 Deque 接口, 所以 LinkedList 可以作为双端队列, 同时 LinkedList 的双向链表的特点，还可以作为 Stack 使用, 但是 LinkedList 的这2个功能，如果没有什么特殊的要求的话，都可以使用 ArrayDeque 替代。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 08:41:09 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;LinkedList&quot;&gt;&lt;a href=&quot;#LinkedList&quot; class=&quot;headerlink&quot; title=&quot;LinkedL
      
    
    </summary>
    
      <category term="Java" scheme="http://lcn29.github.io/categories/Java/"/>
    
      <category term="Collection" scheme="http://lcn29.github.io/categories/Java/Collection/"/>
    
    
      <category term="Java" scheme="http://lcn29.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList</title>
    <link href="http://lcn29.github.io/2019/08/13/ArrayList/"/>
    <id>http://lcn29.github.io/2019/08/13/ArrayList/</id>
    <published>2019-08-13T02:31:43.000Z</published>
    <updated>2019-08-17T08:12:46.135Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 08:41:08 GMT+0800 (GMT+08:00) --><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>了解 ArrayList 之前, 我们需要先了解一下数组的特点</p><blockquote><ol><li>数组的内存是连续的，不存在相邻元素之间还隔着其他内存</li><li>数组内存储的数据类型都是一样的</li><li>数组具备了查询快，增删慢的特点</li></ol></blockquote><h2 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>结构图:<br><img src="https://s2.ax1x.com/2019/08/13/m9FHVs.png" alt="Alt &#39;ArrayList&#39;"></p><ul><li>ArrayList的创建<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据存放的地方 */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 不指定容量, 创建对象用到 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 创建容量为0的对象时用到 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不指定容量创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定容量创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过已用的集合对象进行创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// ArrayList c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="comment">// 此处做一个容错处理： c.toArray() 不一定会返回 Object[] 对象</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用一个空的数组进行替代</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从代码可知</p><blockquote><ol><li>ArrayList是基于数组实现的, 所以具备了数组的所有特点</li><li>数据会转为了Object, 同时存放在elementData这个对象中,</li><li>如果在创建是如果不指定容量, 则会把存放数据的对象指向一个空的数组, 指定了参数的, 就创建对应容量的数组</li><li>Collection.toArray()的解释, 看一下这个</li></ol></blockquote><ul><li>ArrayList的添加元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 默认创建时的容量 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ArrayList的最大容量 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当前数组中真实数据数量 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  添加元素, 默认追加在最后面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定位置添加元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断一下 index 是否在已有的数据里面</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 走一遍判断扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>); </span><br><span class="line">    <span class="comment">// 新建一个数组  数组的内容和当前的数据一样，把index后面的数据都往后退一位, 然后index位置变为null</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    <span class="comment">// 设置 index 的元素为要插入的数据</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 走一遍判断当前需要的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算当前需要的最小容量 (当容量的为0时，初始为10)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否需要扩大容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩大elementData的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oldCapacity &gt;&gt; 1  相当于  oldCapacity/2的一次方  也就是  oldCapacity * 0.5</span></span><br><span class="line">    <span class="comment">// 也就是 数组的扩容 = 原来的容量 * 1.5</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再此扩容到  Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Arrays.copyOf 内部时调用  System.arraycopy() 方法进行扩容的</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 当需要的容量超过了MAX_ARRAY_SIZE, 扩大到 Integer.MAX_VALUE </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从代码中, 我们可以指定往ArrayList中添加数据的过程</p><blockquote><ol><li>先计算一下当前实际需要的容量 <code>site + 1</code></li><li>判断一下存储数据的 <code>elementData</code>是否为空，为空的话，说明在初始ArrayList时，没有指定容量，默认设置当前需要的容量为10</li><li>需要的容量大于当前存储数据的<code>elementData</code>的长度, 进行扩容。 没有的话，直接存到 <code>elementData</code>中</li><li>扩容时<blockquote><ol><li>计算一下当前应该扩容的容量 = 当前的容量 * 1.5 (oldCapacity + (oldCapacity &gt;&gt; 1))</li><li>如果计算出来的容量还小于当前需要的容量, 则当前扩容的容量 = 需要的容量</li><li>当前扩容的容量大于了Integer.MAX_VALUE - 8 (MAX_ARRAY_SIZE), 则继续扩大到 当前容量 = Integer.MAX_VALUE</li><li>调用 Arrays.copyOf方法(内部通过System.arraycopy调用原始方法)进行扩容</li></ol></blockquote></li></ol></blockquote><p>从流程我们可以指定</p><blockquote><ol><li>ArrayList添加元素时, 都会去判断一下当前的容量是否足够</li><li>ArrayList没有指定初始容量时, 默认为10</li><li>ArrayList的存储上限为 Integer.MAX_VALUE</li><li>数组每次扩容都需要通过System.arraycopy，创建新的数组对象，然后拷贝已有的数据过去，这是一个很耗时的操作，所以如果初始时知道数据的大小，指定ArrayList的大小</li><li>指定位置的插入每次都会导致数组指定位置后面的数据往后移动一位</li></ol></blockquote><ul><li>ArrayList的删除元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 index是否合法</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 取到需要删除的元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 删除的元素所在的位置后面还有多少个元素</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将 elementData index+1 开始到 numMoved个元素依次放到elementData的index处的后面</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    <span class="comment">// 设置 site - 1 处的元素为空</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定对象的删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="comment">// 调用Object的 equals比较2个对象是否为同一个</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过索引找到对应的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除元素和 remove(int) 类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从代码中, 我们可以从ArrayList中删除数据的过程</p><blockquote><ol><li>找到需要删除的元素的索引 index</li><li>然后把索引index后面的元素拼接到index后面</li></ol></blockquote><ul><li>ArrayList的查询元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检测 index 是否符合条件</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 通过索引获取元素</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>ArrayList的获取元素, 就不要讲了吧，通过索引index直接从数组[index]获取</p><h2 id="ArrayList补充"><a href="#ArrayList补充" class="headerlink" title="ArrayList补充"></a>ArrayList补充</h2><ol><li>ArrayList 实现了 Serializable 接口, 那么他是支持序列化的, 但是他的数据是存放在 elementData 内, elementData却被 transient(对象序列化时忽略) 修饰了？</li></ol><p>我们知道 elementData 本质是一个数组，使用数组是我们需要先定义长度, 所以可能存在就是我们的数据只要3个,但是 elementData 的长度为10, 7个数据是没有的, 在序列化时, 将这几个没有的数据序列过去, 浪费了空间和浪费时间, 所以 ArrayList将 elementData设置为不用序列化的, 然后自身重写了序列化方法 <code>writeObject</code> 和 反序列化方法 <code>readObject</code>, 只把 elementData 内有效的数据序列化过去</p><ol start="2"><li>在ArrayList的 add, remove, clear 方法的调用, 可以看到 有个这行代码 <code>modCount++</code> modCount的作用？</li></ol><p>这个变量是继承与父类 AbstractList 的, 这个变量记录的是：当前 ArrayList 的修改次数, 作用：用于支持 fail-fast机制(在遍历中, 发现数据被修改过了, 直接抛出异常)<br>ArrayList 内部自己实现了一个 Iterator (代码有省略), 通过 ArrayList.iterator() 获取到的就是这个实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码我们可以知道</p><blockquote><ol><li>Iterator 内部维护了一个 expectedModCount 他的值就是当前ArrayList内部数据修改过几次了</li><li>每次遍历时, 都会判断 expectedModCount 的值是否等于 当前 modCount, 不等于直接抛异常, 不进行后续操作了</li><li>上面的场景很大概率出现在多线程上, 一个线程在遍历， 另一个线程对ArrayList进行了修改, modCount + 1 了, 从而使得 modCount != expectedModCount, 遍历的线程立即抛出异常</li><li>modCount 在 AbstractList 只是被修饰为 transient的, 没有用 volatile 修饰, 也就是存在一个线程修改了数据 但是 modCount 没有及时写到内存中，遍历线程还是能够继续执行。 所以fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。</li></ol></blockquote><ol start="3"><li>ArrayList不是一个线程安全的集合？</li></ol><p>ArrayList是线程不安全的, 如果需要保证线程的安全性, 可以考虑使用 CopyOWriteArrayList 或者使用 Collections.synchronizedList(Lise l) 函数返回一个线程安全的ArrayList类</p><ol start="4"><li>ArrayList 实现了 RandomAccess 接口有什么用？</li></ol><p>首先 RandomAccess 的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从定义可以看到 RandomAccess 接口, 没有任何的东西需要我们实现, 他只做一种标示作用, 实现这个接口的类, 表示自身是支持 “随机访问”(如果有10个元素, 我们需要访问第5个, 就能直接跳到第5个进行访问, 忽略掉前面的4个元素, 还有一个顺序访问, 无论要访问第几个元素, 都需要从第一个元素开始, 一直往下找, 直到找到了需要的位置为止) 策略的(官网还特意说明了, 如果是实现了这个接口的 List, 使用for循环的方式获取数据会优于用迭代器获取数据)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 支持 随机访问  或者当前的数据量 小于 5000</span></span><br><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line"><span class="comment">// 可以到源码里面看一下这个方法， 内部是通过 white 进行遍历的</span></span><br><span class="line">            <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 这个 是使用 迭代器遍历的</span></span><br><span class="line">            <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 08:41:08 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList
      
    
    </summary>
    
      <category term="Java" scheme="http://lcn29.github.io/categories/Java/"/>
    
      <category term="Collection" scheme="http://lcn29.github.io/categories/Java/Collection/"/>
    
    
      <category term="Java" scheme="http://lcn29.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Collection.toArray的理解</title>
    <link href="http://lcn29.github.io/2019/08/12/Collection-toArray%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://lcn29.github.io/2019/08/12/Collection-toArray的理解/</id>
    <published>2019-08-12T13:53:52.000Z</published>
    <updated>2019-08-17T06:01:25.173Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 08:41:08 GMT+0800 (GMT+08:00) --><h1 id="Collection-toArray方法的理解"><a href="#Collection-toArray方法的理解" class="headerlink" title="Collection.toArray方法的理解"></a>Collection.toArray方法的理解</h1><p>在查看 ArrayList 的源码的时候，发现了下面的一句话 <code>c.toArray might (incorrectly) not return Object[] (see 6260652)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情可以查看<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652" target="_blank" rel="noopener">这里</a>, 出于好奇, 理了一下</p><h2 id="对象向上转型时"><a href="#对象向上转型时" class="headerlink" title="对象向上转型时"></a>对象向上转型时</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String str = <span class="string">"123"</span>;</span><br><span class="line">Object obj = str;</span><br><span class="line">Object obj2 = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class java.lang.String</span></span><br><span class="line">System.out.println(str.getClass());</span><br><span class="line"><span class="comment">// class java.lang.String</span></span><br><span class="line">System.out.println(obj.getClass());</span><br><span class="line"><span class="comment">// class java.lang.String</span></span><br><span class="line">System.out.println(obj2.getClass());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer num = <span class="number">1</span>;</span><br><span class="line">Number obj3 = num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class java.lang.Integer</span></span><br><span class="line">System.out.println(num.getClass());</span><br><span class="line"><span class="comment">// class java.lang.Integer</span></span><br><span class="line">System.out.println(obj3.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码, 我们可以发现通过向上转型, 虽然对象已经是转型后的类型了，但是还是会保留了实际的类型</p><h2 id="对象为数组时"><a href="#对象为数组时" class="headerlink" title="对象为数组时"></a>对象为数组时</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Object[] obj = <span class="keyword">new</span> Object[<span class="number">2</span>];</span><br><span class="line">obj[<span class="number">0</span>] = <span class="keyword">new</span> String();</span><br><span class="line"></span><br><span class="line"><span class="comment">// class java.lang.String</span></span><br><span class="line">System.out.println(obj[<span class="number">0</span>].getClass());</span><br><span class="line"><span class="comment">// class [Ljava.lang.Object;</span></span><br><span class="line">System.out.println(obj.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码, 我们可以发现声明的数组是什么类型，那么他的类型就是什么。 但是放入到内部的对象, 通过转型存到了数组里面, 但是他的实际类型还是没变的。</p><h2 id="Collection-toArray"><a href="#Collection-toArray" class="headerlink" title="Collection.toArray()"></a>Collection.toArray()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"123"</span>);</span><br><span class="line">Object[] objArray = list.toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// class [Ljava.lang.Object;</span></span><br><span class="line">System.out.println(objArray.getClass());</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list2 = Arrays.asList(<span class="string">"123"</span>);</span><br><span class="line">Object[] objArray2 = list2.toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// class [Ljava.lang.String;</span></span><br><span class="line">System.out.println(objArray2.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList.toArray()返回的是 Object[], 同时实际类型也是Object[]<br>从官方的说法中我们可以知道, 正常情况下 <code>Collection.toArray()</code>和<code>Collection.toArray(new Object[0])</code>的返回类型应该是一样的。<br>但是<code>Arrays.toArray()</code>并不符合这一条件。 <code>ArrayList</code> 在创建时就用一个 Object 数组存放所有的对象, 传递到 <code>Arrays.copyOf(T[] original, int newLength)</code> 时 T为Object, 所以转换后的对象为Object。</p><p>Arrays.toArray() 返回的是 T[]<br>Arrays内部自己实现了一个 <code>ArrayList</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通过泛型创建了 数组 E[]  如果传递过来的是 String, 那么此时 a的类型为 String[] */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通过clone() 返回的是原本的类型 也就是此时 E[], 同时向上转型为Object[], 但是次数虽然类型是Object, 但是他的实际类型为 E[] */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> a.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是Arrays.toArray() 返回的时创建时指定的泛型类型。</p><h2 id="回到ArrayList的创建方法"><a href="#回到ArrayList的创建方法" class="headerlink" title="回到ArrayList的创建方法"></a>回到ArrayList的创建方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 通过这种方式创建ArrayList时, elementData的类型应该是 String</span></span><br><span class="line"><span class="keyword">new</span> ArrayList(Arrays.asList(<span class="string">"12323"</span>));</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 08:41:08 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Collection-toArray方法的理解&quot;&gt;&lt;a href=&quot;#Collection-toArray方法的理解&quot; class=&quot;
      
    
    </summary>
    
      <category term="Java" scheme="http://lcn29.github.io/categories/Java/"/>
    
      <category term="Collection" scheme="http://lcn29.github.io/categories/Java/Collection/"/>
    
    
      <category term="Java" scheme="http://lcn29.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java容器(集合)类</title>
    <link href="http://lcn29.github.io/2019/08/11/Java%E5%AE%B9%E5%99%A8(%E9%9B%86%E5%90%88)%E7%B1%BB/"/>
    <id>http://lcn29.github.io/2019/08/11/Java容器(集合)类/</id>
    <published>2019-08-11T06:41:41.000Z</published>
    <updated>2019-08-23T02:14:11.464Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 08:41:09 GMT+0800 (GMT+08:00) --><h1 id="Java容器-集合-类"><a href="#Java容器-集合-类" class="headerlink" title="Java容器(集合)类"></a>Java容器(集合)类</h1><p>java的集合框架是我们平时使用频率挺高的代码, 基本涉及到数据的临时存储, 都能见到他们的身影。 但是在庞大的集合类中,找到一个最适合自己需求的实现类，则需要你对Java的集合框架有一定的了解。 本文将从全局出发，整理一下java的集合框架。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>整个Java集合框架的关系图如下(本图为基础版):<br><img src="https://s2.ax1x.com/2019/08/11/ejvwIs.png" alt="Alt &#39;Java集合框架&#39;"><br>从图中我们可以看出, Java的集合框架大体分成2派: Collection 和 Map</p><p>Collection主要有3个成员</p><blockquote><ol><li>List 存储在内部的数据是有序的, 同时可重复</li><li>Set 不能有重复元素</li><li>Queue 队列,可以保证数据的先进先出</li></ol></blockquote><p>Map 则比较简单, 是一个key-value模式的存储结构，要求key不能重复，通过key可以获取到唯一的value。</p><h2 id="具体介绍"><a href="#具体介绍" class="headerlink" title="具体介绍"></a>具体介绍</h2><ul><li>List</li></ul><p>1 有序(元素存入集合的顺序和取出的顺序一致), 元素都有索引, 同时支持重复元素。<br>2 除了具有Collection接口必备的iterator()方法外, List还提供一个listIterator()方法, 返回一个ListIterator接口。 Iterator的遍历都是从头开始一直往后遍历的，但是listIterator可以指定从哪个位置开始遍历, 同时支持往前遍历，同时增加元素, 修改元素</p><p>优点：操作读取操作效率高，基于数组实现的，可以为null值，可以允许重复元素，有序，异步。<br>缺点：由于它是由动态数组实现的，不适合频繁的对元素的插入和删除操作，因为每次插入和删除都需要移动数组中的元素。</p><blockquote><ol><li>ArrayList, <a href="/2019/08/13/ArrayList/">详情</a></li><li>LinkedList, <a href="/2019/08/17/LinkedList/">详情</a></li><li>Vector 可以看成是一个线程安全的ArrayList, 因为他的内部大部分的方法都是通过 <code>synchronized</code> 进行修饰的, 和 ArrayList的区别是, 支持设置每次扩容的容量(ArrayList 默认是当前的0.5倍), 如果没有设置, Vector 默认是当前的1倍, Vector不被推荐使用了</li><li>Stack 基础了Vector, 同时提供了符合栈特点的5个方法： push, pop, peek, search, empty。 研究Stack 本质就是在研究 Vetor, 所以这里就不进行讲解了。 而且 Stack 类官方已经不在建议使用了(Stack的实现有许多不规范的地方), 现在官方推荐使用 <code>java.util.Deque</code>。</li></ol></blockquote><ul><li>Set</li></ul><p>1 无序(存入和取出顺序有可能不一致), 不可以存储重复元素<br>2 当存入的元素重复了, 后面的会替换已有的</p><blockquote><ol><li>HashSet <a href="/2019/08/20/HashSet/">详情</a></li><li>TreeSet <a href="https://www.jianshu.com/p/12f4dbdbc652" target="_blank" rel="noopener">详情</a></li></ol></blockquote><ul><li>Queue</li></ul><p>1 Queue用于模拟队列这种数据结构，实现’FIFO’等数据结构<br>2 队列常作被当作一个可靠的将对象从程序的某个区域传输到另一个区域的途径<br>3 队列不允许随机访问队列中的元素<br>4 使用 Queue 实现通常不允许插入 null 元素, 因为 null 也用作 poll 方法的一个特殊返回值，表明队列不包含元素了。<br>5 在 Java 中 和 Queue 直接关联的类有 BlockingQueue(还是一个接口, 只是基础了Queue的方法), Deque(还是一个接口, 为了规范为双向队列, 还添加了一下自身的方法), AbstractQueue(抽象类, 封装了一层)</p><blockquote><ol><li>ArrayDeque <a href="/2019/08/17/ArrayDeque/">详情</a></li><li>ArrayBlockingQueue <a href="http://benjaminwhx.com/2018/05/07/%E3%80%90%E7%BB%86%E8%B0%88Java%E5%B9%B6%E5%8F%91%E3%80%91%E8%B0%88%E8%B0%88ArrayBlockingQueue/" target="_blank" rel="noopener">详情</a></li><li>LinkedBlockingQueue <a href="http://benjaminwhx.com/2018/05/11/%E3%80%90%E7%BB%86%E8%B0%88Java%E5%B9%B6%E5%8F%91%E3%80%91%E8%B0%88%E8%B0%88LinkedBlockingQueue/" target="_blank" rel="noopener">详情</a></li></ol></blockquote><ul><li>Map</li></ul><p>1 Map主要用于存储健值对, 根据键得到值, 因此不允许键重复, 但允许值重复<br>2 是一个双列集合，有两个泛型key和value，使用的时候key和value的数据类型可以相同, 也可以不同</p><blockquote><ol><li>HashMap <a href="/2019/08/20/HashMap/">详情</a></li><li>TreeMap <a href="https://cloud.tencent.com/developer/article/1121260" target="_blank" rel="noopener">详情</a></li><li>Hashtable <a href="https://www.cnblogs.com/skywang12345/p/3310887.html" target="_blank" rel="noopener">详情</a></li><li>LinkedHashMap <a href="https://www.jianshu.com/p/8f4f58b4b8ab" target="_blank" rel="noopener">详情</a></li><li>Properties <a href="https://www.jianshu.com/p/52f8ad17d54a" target="_blank" rel="noopener">详情</a></li></ol></blockquote><h2 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h2><p>List: 数据可重复, 同时有序</p><p>ArrayList<br>1) 基于数组实现的, 同时支持动态扩容<br>2) 随机访问效率高，随机插入、随机删除效率低<br>3) 线程不安全<br>4) 允许放入null, 同时支持多个null</p><p>LinkedList<br>1) 基于双向链表实现<br>2) 随机访问效率低，但随机插入、随机删除效率高<br>3) 线程不安全<br>4) 允许放入null, 同时支持多个null</p><p>Vector<br>1) 基于数组实现的, 同时支持动态扩容<br>2) 随机访问效率高，随机插入、随机删除效率低<br>3) 线程安全<br>4) 为了线程安全, 大部分的方法都通过 synchronized 进行修饰, 所以在效率上比ArrayList慢一些<br>5) 允许放入null, 同时支持多个null<br>6) 不推荐使用Vector, 大部分都加锁，导致了效率低, 而这个加锁很多时候都是你不需要的</p><p>Stack<br>1）继承于Vector, 具备了Vector的所有特性<br>2) 同样的不推荐使用Stack, 如果需要使用栈的话，官方推荐的是ArrayDeque</p><p>Set: 数据唯一, 数据无序</p><p>HashSet<br>1) 基于HashMap实现的, 也就是 数组 + 链表 + 红黑树 实现的。<br>2）我们放入的内容, 存在了内部HashMap 的key, value 统一为 Object<br>3) 线程不安全<br>4）允许存入null, 但是只支持1个, 默认后者覆盖前者</p><p>TreeSet<br>1) 基于TreeMap实现的, 也就是红黑树<br>2) TreeMap 存入的数据是有序的, 默认按照存入的值的hashCode的大小进行排序。 也可以通过实现Comparator接口, 自定义排序规则。<br>3) 线程不安全<br>4）不允许存null</p><p>Queue: 数据可重复, 同时有序, 但是存入和取出的顺序是相反的</p><p>ArrayDeque<br>1) 基于数组实现的双端队列<br>2）随机访问效率高，随机插入、随机删除效率低<br>3）线程不安全<br>4）不允许存入null<br>5) 不仅可以当做双端队列使用，还可以用于栈</p><p>ArrayBlockingQueue<br>1) 基于数组实现的阻塞队列, 不支持扩容<br>2）线程安全的<br>3）不允许存入null</p><p>LinkedBlockingQueue<br>1）基于双向链表实现的<br>2) 随机访问效率低，但随机插入、随机删除效率高<br>3) 线程安全<br>4）不允许存入null</p><p>Map: 数据需要有key-value的映射关系</p><p>HashMap<br>1）基于 数组 + 链表 + 红黑树 实现的<br>2）存入的数据是无序的,<br>3) 线程不安全<br>4) 允许存入null, 但是只支持1个, 默认后者覆盖前者</p><p>TreeMap<br>1） 基于 红黑树 实现的<br>2） 存入的数据是有序的, 默认按照存入的值的hashCode的大小进行排序。 也可以通过实现Comparator接口, 自定义排序规则。<br>3） 线程不安全<br>4） key不允许存入null, value 可以</p><p>Hashtable<br>1) 基于数组 + 链表实现的<br>2）线程安全的<br>3） key 不能为 null, value 也不能为 null</p><p>LinkedHashMap<br>1）基于数组 + 双向链表 实现的<br>2）线程非安全的<br>3）key,value 都能为null</p><p>Properties<br>1) 基于Hashtable 实现的，具有Hashtable的特点</p><hr><p>参考：<br><a href="https://www.cnblogs.com/yysbolg/p/9230184.html" target="_blank" rel="noopener">集合类–最详细的面试宝典–看这篇就够用了(java 1.8)</a><br><a href="https://www.xttblog.com/?p=3416" target="_blank" rel="noopener">从 java.util.Stack 的原理说它为什么不被官方所推荐使用！</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 08:41:09 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Java容器-集合-类&quot;&gt;&lt;a href=&quot;#Java容器-集合-类&quot; class=&quot;headerlink&quot; title=&quot;Java容
      
    
    </summary>
    
      <category term="Java" scheme="http://lcn29.github.io/categories/Java/"/>
    
      <category term="Collection" scheme="http://lcn29.github.io/categories/Java/Collection/"/>
    
    
      <category term="Java" scheme="http://lcn29.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>快速搭建一个自己的博客</title>
    <link href="http://lcn29.github.io/2019/08/04/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://lcn29.github.io/2019/08/04/快速搭建一个自己的博客/</id>
    <published>2019-08-04T06:36:50.000Z</published>
    <updated>2019-08-04T08:18:06.297Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 08:41:09 GMT+0800 (GMT+08:00) --><h1 id="快速搭建一个自己的博客"><a href="#快速搭建一个自己的博客" class="headerlink" title="快速搭建一个自己的博客"></a>快速搭建一个自己的博客</h1><p>做一个自己的博客网站，基本可以从很多方面入手。从购买服务器到自己编写页面，从dns到页面优化。投入的越多,理所当然的你的网站体验就越好等。但是考虑到时间,价钱等原因，我们可以站在前人的基础上，选择最合适方式搭建自己的网站, 达到快速的搭建。</p><h2 id="技术选择"><a href="#技术选择" class="headerlink" title="技术选择"></a>技术选择</h2><blockquote><ol><li>GitHub + Hexo + Markdown (推荐)</li><li>GitHub + Jekyll + Markdown</li><li>自选服务器 + Wordpress + 插件</li><li>…</li></ol></blockquote><p>从免费的角度出发的话,很多人都会选择前2种吧。 而hexo是需要node环境,jekeyll需要ruby，同时hexo有现成的中文文档，所以在搭建本站是采用了Hexo,环境搭建简单的同时还有中文文档。</p><p>那么开始吧,我们的博客搭建之路</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li><p>1.因为用到了Github，所以需要你本地有git的环境<br>window 可以到Git的官网下载一个<a href="https://gitforwindows.org/" target="_blank" rel="noopener">GitBash</a>，一路默认配置安装就行了。</p></li><li><p>node环境安装<br>到node的官网下载一个<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node</a>，双击安装就行了。</p></li><li><p>2.安装hexo<br>打开你的cmd,执行一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完,执行下面的命令, 可以打印出hexo-cli 的版本号,就是安装完成了</span></span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure></li><li><p>3.初始你的博客工作空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新版本的hexo,在你初始的过程中,会把你项目的依赖都下来了, 也就是npm install 可以不应执行了</span></span><br><span class="line">hexo init 你的工作空间的名字</span><br></pre></td></tr></table></figure></li><li><p>4.启动你的项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入到你的工作空间</span></span><br><span class="line"><span class="built_in">cd</span> /你的工作空间的名字</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包，生成网站的文件</span></span><br><span class="line">hexo g </span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动项目</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li></ul><p>这时打开你的浏览器,访问 <code>http://localhost:4000</code>就能看到你的网站了,如果想要停止的话, 在你的命令窗口输入<code>ctrl+C</code>就行了,自此你的环境就搭建成功了。</p><p>如果你有将东西备份在GitHub的习惯的话，或者利用Github来做版本管理等,这时候可以把你的项目放到Github上了,步骤可以参考<a href="/2019/08/04/Git提交/">这里</a></p><h2 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h2><p>hexo初始的主题是不是有点丑呢?这时候，如果你是一个前端大佬，想要从0 开始，自定义想要的页面样子的话，可以参考官网的<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">文档</a>进行开发了. 如果你和我一样，对自己的审美,适配等原因而无奈的话，我们可以套用别人分享的主题。</p><ul><li><p>1.主题寻找<br>首先进入hexo<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>,你可以看到有很多别人分享的主题,从中选择一款你喜欢的, 本站使用的主题是这个：<a href="http://sora3.coding.me/" target="_blank" rel="noopener">gal</a>, 感谢作者的分享。说明一下，网上找的的资料，大部分的人都是以<a href="https://theme-next.org/" target="_blank" rel="noopener">Next</a>为例子, 文档挺全的,同时next主题也有很多人进行2次开发,样子也都挺好看的，所以如果你没有什么要求，可以尝试使用next, 后面的配置,改造有很多巨人肩膀可以给你依靠。</p></li><li><p>2.导入主题</p></li></ul><blockquote><ol><li>找到了自己想要的主题后, 可以点击一下主题的标题，正常情况下是可以进入到作者分享的主题的github仓库。仓库的克隆地址。</li><li>打开你本地项目的目录, 进入到你的themes目录,然后把刚刚的主题仓库克隆下来,把文件夹的名字复制下来</li><li>回到你项目的根目录, 打开<code>_config.yml</code>, 有的主题在他们仓库的readme,有教你们如何配置,很多都是会把他们仓库名和主题名弄混淆,比如: <code>hexo-theme-A-RSnippet</code> ,文档说的配置是<code>a-rsnippet</code>,之所以能起作用,是他们在克隆仓库时,指定了本地的文件夹名,但是这一步很多文档是没有说的，所以很容易出现你的themes下的主题是<code>hexo-theme-A-RSnippet</code>, 但是你的配置是<code>a-rsnippet</code>，所以主题不起作用.</li></ol></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把theme修改为你的第二步复制下来的文件夹名, </span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">文件夹名(themes下一定要有和它对应的名字一模一样的主题存在)</span></span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li>安装你想要的主题的配置文档进行其他相对应的配置。比如我使用的gal主题,需要先安装<code>hexo-renderer-sass</code>和<code>hexo-renderer-scss</code>, 才能将主题里面的scss文件编译成css文件</li><li>启动项目, 这时你的的主题已经起作用了(下面的就是启动命令,后续的重启服务基本都是需要走一遍这个流程)</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clean 清除上一次生成的文件   </span></span><br><span class="line">hexo clean </span><br><span class="line"><span class="comment"># 重新生成新的文件</span></span><br><span class="line">hexo g </span><br><span class="line"><span class="comment"># 启动你的服务</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><blockquote><ol start="6"><li>这时,如果你想把可以代码提交到Github时,会报错<code>You&#39;ve added another git repository inside your current repository.</code> 大概的意思是你仓库里面有另一个仓库(你的主题仓库)。解决：进入到themes/你下载的主题/里面, 删除里面的<code>.git</code>文件，在回到你的项目的跟目录 <code>git rm --cached -f themes/你下载的主题/</code>,后面你就能提交了</li></ol></blockquote><h2 id="定制化你的博客"><a href="#定制化你的博客" class="headerlink" title="定制化你的博客"></a>定制化你的博客</h2><p>这个基本可以通过查看对应主题的文档进行改造，比如添加<code>归档</code>,<code>404页面</code>等,根据自己的需要和对应主题的文档进行修改就行了。</p><h2 id="新建你的文章"><a href="#新建你的文章" class="headerlink" title="新建你的文章"></a>新建你的文章</h2><p>开始你的书写博客之路了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 文章的名字</span><br></pre></td></tr></table></figure><p>这时在 你的项目的根目录<code>/source/_posts</code> 下面有一个 <code>你命名的文章的名字.md</code>的文件。打开,你就可以通过markdown写下你的内容了(注头部的内容不能删除), 重新走一遍从重启服务, 这是你就能看到你写的文章了。</p><h2 id="发布你的博客"><a href="#发布你的博客" class="headerlink" title="发布你的博客"></a>发布你的博客</h2><p>利用Github Pages功能,部署到服务器, 方便别人可查看, 不了解GitHub Pages的可以先看一下<a href="/2019/08/01/GitHubPages介绍/">这里</a><br>(1) 先建立一个仓库名为<code>{你的GitHub的用户名}.github.io</code>的仓库,然后把它克隆到你本地,<br>(2) 把博客项目里的<code>public</code>目录内的所有的文件复制到刚克隆下来的仓库里,然后提交到GitHub上<br>(3) 这是通过浏览器访问<code>https://{你的GitHub的用户名}.github.io</code>就能访问到你的网站了<br>到此你网站就算是完成了,但是这是最简单的一个静态网站，只具备了看的功能，我们来为我们的网站增加功能吧</p><h2 id="自动发布代码到你仓库"><a href="#自动发布代码到你仓库" class="headerlink" title="自动发布代码到你仓库"></a>自动发布代码到你仓库</h2><p>每次你修改了文章等,如果都要重复上面的步骤(1)(2),是一个麻烦的过程,而Hexo为我们提供了一个插件,用于省略发布的过程(Hexo还提供了很多插件，有兴趣的可以到官网了解一下)<br>(1)配置你本地能够免密(SSH方式)提交代码到Github, 配置的过程可以查看<a href="/2019/08/04/Github免密提交/">这里</a><br>(2)安装自动发布插件 <code>npm install hexo-deployer-git --save</code><br>(3)在根目录的<code>_config.xml</code>文件添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span></span><br><span class="line"><span class="attr">    git:</span> <span class="string">你GitHub</span> <span class="string">Pages仓库的地址,注意此次需要为ssh的地址,如果是https的是不能上传的</span></span><br></pre></td></tr></table></figure><p>(4)后续你要把你的页面发布到对应的仓库时,只需要通过下面的命令就能发布到对应的仓库了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><h2 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h2><p>(1) 首先需要你的主题支持评论(现在大多数的主题都支持的,但是不排除没有的是不)<br>(2)评论插件选取</p><blockquote><ol><li>Hypercomments</li><li>来必力</li><li>Gitment</li><li>Gittalk</li><li>…</li></ol></blockquote><p>因为用的主题gal，用到是Gitment(为了可以自定义评论区的样式)，所以此次以Gitment作为例子(Gitment的作者已经一年多没维护这个项目了,所以可以的话，试着换另一个插件),其他的插件，根据对应的文档进行配置就行了。<br>(3)到GitHub的这里注册一个oAuth(Gitment是利用Github的issure作为评论存储的)。地址在<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">这里</a><br><img src="https://s2.ax1x.com/2019/07/30/eJgr1H.png" alt="Alt &#39;GitHub oAuth&#39;"><br>如图：里面的Homepage URL 和 Authorization callback如果你的项目是基于GitPages并且没有绑定自己的域名的话，按照上面的配置就可以了,如果你基于GitPages但是又绑定了自己的域名,则填自己的域名就行了,其他的搭建在自己的服务器的,则填自己服务器的对应的首页。注册成功后，你将会得到一个Client ID和Client Secret。</p><p>(4)按照你的主题的设置,开启对应的设置,然后把client id 和 client secret 配置进你的文件就行了。如下，是gal主题的配置<br><img src="https://s2.ax1x.com/2019/07/30/eJWz8S.md.png" alt="Alt &#39;gal的配置&#39;"><br>这样你的系统就具备了评论的前提了。</p><p>(5)当你的文章开启了评论功能后，你打开页面, 登录后, 你会发现你的文章下有个要你初始评论的按钮，只有你点了初始，才能进行评论。这是因为Gitment是基于GitHub的issues功能的，如果要能发issues，需要有人先开启一个issure，所以你的初始按钮就是起到初始的功能<br><img src="https://s2.ax1x.com/2019/08/04/eyOJ54.png" alt="Alt &#39;评论初始化&#39;"><br>不同主题的这个初始样式是不一样的哦,此处为gal主题的样式,也有可能你的主题是没有这个的</p><h2 id="脚本自动化评论"><a href="#脚本自动化评论" class="headerlink" title="脚本自动化评论"></a>脚本自动化评论</h2><p>如果你一次添加了很多文章，那么后续发布后, 你需要手动的登录你的网站，然后一个个的给他们初始化评论, 对自己不太好吧。我们可以通过脚本的形式每次给没有初始化过的文章自动初始。</p><p>(1)首先你需要一个access token允许你通过api的方式操作你的仓库。Access token的申请，可以点<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">这里</a>, 点击右上角的<code>Generate new token</code>, 输入你的登录密码后，就能看到下面的<br><img src="https://s2.ax1x.com/2019/07/30/eJ4ZX4.md.png" alt="Alt ‘AccessToken’"> 只需要把repo的勾上，点击Generate Token就行了。这时你会得到一串秘钥。保存起来,同时不要泄露了,如果其他人得到了这个秘钥，那么就可以通过api的方式操作你的仓库了。</p><p>(2)安装可以生成网站生成站点图的插件(站点图：就是一个包含你网站所有的网页的文件,便于搜索引擎抓取你的网站)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>(3)在你的项目的的配置文件里面加上</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网站站点图</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">sitemap/sitemap.xml</span>    </span><br><span class="line"><span class="comment"># 百度站点图</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">sitemap/baidusitemap.xml</span></span><br></pre></td></tr></table></figure><p>有了这个配置那么后续你的打包，都会在public目录下面生成一个sitemap目录,目录里面有2个上面配置的文件,这2个文件都是用于搜索引擎抓取你的网站用的, 只是一个是专门给百度用，一个是通用的</p><p>(4) 新建一个自己初始脚本<br>脚本的内容在 <a href="https://github.com/LCN29/HexoGenerator/blob/master/initComment.js" target="_blank" rel="noopener">这里</a>。(里面的配置的Token已经失效了, Github在你把代码提交的时候，检测到里面有对应的Token，就会将你的token失效掉，所以当你的代码提交到Github时为了不让token失效，需要先把他删除了,再提交) 放到你的项目的根目录，这个脚本需要你根据自己的主题进行修改，里面最重要的是这个</p><p>(5) token的管理<br>因为GitHub不允许在脚本里面出现token，但是如果token不好保存，这个还会限制到你的异地开发。可以利用<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis</a>管理你的仓库，同时管理你的token。因为这个东西, 我还在摸索中，就不介绍了</p><h2 id="添加统计"><a href="#添加统计" class="headerlink" title="添加统计"></a>添加统计</h2><p>有了统计功能能够帮你更清晰的认清你的网站的情况,而我们的网站是一个静态的网站,想要拥有统计的功能,就需要借助第三方的服务了。<br>现在第三方的插件已知的有2种:leancloud和不蒜子。但是使用这2个需要你的主题支持(不支持的话，当然你也可以对页面进行修改的), 在我这边的使用中：leancloud用于在文章的访问量统计,不蒜子用于网站的访问量的统计。</p><p>(1)不蒜子的使用：<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">这里</a>。使用很简单,在你的项目的根目录 <code>themes/你的主题/layout/_partial/head.ejs/swing</code> 引入想要的js文件,然后在 <code>themes/你的主题/layout/_partial/footer.ejs/swing</code>引入对应的统计标签就行了</p><p>(2) leancloud: 使用leancloud需要实名认证，所以我的博客没有使用(在gal主题, 不使用leancloud,那么首页的文章的阅读量就无法获取了,受到了影响就这个,进入到每篇文章的的页面，文章的阅读量还是可以通过不蒜子实现的),但是Leancloud是Hexo推荐的统计插件,还是可以试着使用一下的。使用的话，可以参考<a href="https://www.jianshu.com/p/702a7aec4d00" target="_blank" rel="noopener">这里</a></p><h2 id="添加live-2d-也就是页面左下角的小人了"><a href="#添加live-2d-也就是页面左下角的小人了" class="headerlink" title="添加live-2d(也就是页面左下角的小人了)"></a>添加live-2d(也就是页面左下角的小人了)</h2><p>(1) 安装对应的插件 <code>npm install --save hexo-helper-live2d</code><br>(2) 然后到<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">这里</a>可以找到部分live-2d模型的预览，挑选一个自己喜欢的，复制下名字<br>(3) 安装对应的模型<code>npm install --save npm install live2d-widget-model-模型的名称</code><br>(4) 在你项目的根目录新建一个文件夹<code>live2d_models</code>,然后到node_modules文件夹中找到刚刚下载的live2d模型，将其复制到live2d_models中<br>(5) 配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  scriptFrom:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line"><span class="attr">  pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line"><span class="attr">  pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line"><span class="attr">  tagMode:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  debug:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    use:</span> <span class="string">live2d-widget-model-模型的名称</span></span><br><span class="line"><span class="attr">  display:</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">left/right</span> </span><br><span class="line"><span class="attr">    width:</span> <span class="number">150</span>  <span class="string">(live-2d</span> <span class="string">的显示宽)</span></span><br><span class="line"><span class="attr">    height:</span> <span class="number">400</span> <span class="string">(live-2d</span> <span class="string">的显示高)</span></span><br><span class="line"><span class="attr">  mobile:</span></span><br><span class="line"><span class="attr">    show:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  react:</span></span><br><span class="line"><span class="attr">    opacity:</span> <span class="number">0.9</span></span><br></pre></td></tr></table></figure><h2 id="点击心形效果"><a href="#点击心形效果" class="headerlink" title="点击心形效果"></a>点击心形效果</h2><p>(1)引入<a href="https://github.com/LCN29/HexoGenerator/blob/master/themes/hexo-theme-gal/source/js/clicklove.js" target="_blank" rel="noopener">脚本</a>，放到<code>项目的根目录/themes/你下载的主题/source/js/</code><br>(2)打开 <code>项目的根目录/themes/你下载的主题/source/layout/_partial/head.ejs/swing</code> 引入这个js</p><h2 id="Rss功能"><a href="#Rss功能" class="headerlink" title="Rss功能"></a>Rss功能</h2><p>一个类似于订阅的功能,用户点击了rss,就相当于订阅了你，你后续发布了新的文章，订阅的用户就可以知道。(gal主题不支持这个,但是我这个做了一点小修改, 将其放到了个人的链接里面了)</p><p>(1) 安装插件 <code>npm install --save hexo-generator-feed</code></p><p>(2) 配置(这时候你的RSS链接就是 域名/atom.xml)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rss配置</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="string">hexo-generator-feed</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">atom</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">atom.xml</span></span><br><span class="line">    <span class="comment"># 0 全部, atom.xml每次生成容纳多少文章</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>(3)现在你的网站已经支持Rss功能了, 但是用户的使用需要RSS阅读器,rss阅读器的选择可以看<a href="https://sspai.com/post/44420" target="_blank" rel="noopener">这个</a>,我使用的是<a href="https://www.inoreader.com" target="_blank" rel="noopener">InoReader</a>,因为是国外的,所以速度有点慢。</p><h2 id="静态文件压缩"><a href="#静态文件压缩" class="headerlink" title="静态文件压缩"></a>静态文件压缩</h2><p>现在已知的压缩方式有2种: gulp和hexo-neat。 gulp我试过2次，都报错了, 放弃了。 这里介绍一下hexo-neat。<br>(1)安装插件 <code>npm install --save hexo-neat</code><br>(2)配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">neat_enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 压缩html</span></span><br><span class="line"><span class="attr">neat_html:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line">  <span class="comment"># 压缩css  </span></span><br><span class="line"><span class="attr">neat_css:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/*.min.css'</span></span><br><span class="line"><span class="comment"># 压缩js</span></span><br><span class="line"><span class="attr">neat_js:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  mangle:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  output:</span></span><br><span class="line"><span class="attr">  compress:</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/*.min.js'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'**/clicklove.js'</span></span><br></pre></td></tr></table></figure><p>通过这个插件可以对html, css, js进行压缩，但是在压缩js是会报错,可以把上面压缩js的开关关掉就行了。</p><h2 id="关联域名"><a href="#关联域名" class="headerlink" title="关联域名"></a>关联域名</h2><p>本身没有绑定域名，所以没设置,可以参考<a href="https://blog.csdn.net/damienzhong/article/details/84335558" target="_blank" rel="noopener">这个</a></p><h2 id="设置coding-让百度收录"><a href="#设置coding-让百度收录" class="headerlink" title="设置coding,让百度收录"></a>设置coding,让百度收录</h2><p>hexo托管在github了，但是github是国外的，百度的爬虫是不能够爬取github的。如果你希望你做的博客能够在百度引擎上被收录，而且想要更快的访问，那么可以在国内的coding page做一个托管,Coding可以看做是国内版的GitHub,大体的操作和GitHub差不多。</p><p>(1) 到coding注册一个个人账号，记住不是组织账号，现在coding应该被腾讯云整合之类的，所以只能通过qq,微信进行注册了。<br>(2) 在coding建立一个 <code>{你的coding名}.coding.me</code>的仓库,同时开启Pages功能<br>(3) 配置免密登录,可以使用和github一样的公钥<br>(4) 配置一下你的<code>_config.yml</code>文件, 后续你发包后，内容都会在GitHub和Coding同时发布</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部署部分设置</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo:</span><br><span class="line">    coding: git@git.dev.tencent.com:coding用户名/用户名.coding.me.git</span><br><span class="line">    git: git@github.com:用户名/用户名.github.io.git</span><br></pre></td></tr></table></figure><p>这时你能想访问GitHub Pages 一样访问你在coding上的页面了, 格式 <code>https://{你的coding名}.coding.me</code></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>自此, 利用hexo搭建自己的博客的过程就玩了, 上面的流程可以根据自己的需要进行选择,同时也可以增加, 比如引入音乐功能(我的博客就增加了)等其他功能，可以根据自己的需要进行取舍。 同时如开头说的，现在你博客网站的优化是无上限的。<br>(1)比如我们可以把我们的网站的大量图片放到图床上优化网站的加载速度，或者为了保证质量，也可以通过购买其他的服务商的<code>对象存储 OSS</code>做自己的图床<br>(2)在你的网站前面，设置多一次cdn<br>(3)自购服务器, 配合nginx,tomcat等,让网站运行在你自己的服务器上<br>最后,祝各位搭建出自己满意的博客网站</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 08:41:09 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;快速搭建一个自己的博客&quot;&gt;&lt;a href=&quot;#快速搭建一个自己的博客&quot; class=&quot;headerlink&quot; title=&quot;快速搭建一
      
    
    </summary>
    
      <category term="Hexo" scheme="http://lcn29.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://lcn29.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Github免密提交</title>
    <link href="http://lcn29.github.io/2019/08/04/Github%E5%85%8D%E5%AF%86%E6%8F%90%E4%BA%A4/"/>
    <id>http://lcn29.github.io/2019/08/04/Github免密提交/</id>
    <published>2019-08-04T05:52:29.000Z</published>
    <updated>2019-08-04T05:58:48.850Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 08:41:08 GMT+0800 (GMT+08:00) --><h1 id="GitHub免密提交"><a href="#GitHub免密提交" class="headerlink" title="GitHub免密提交"></a>GitHub免密提交</h1><p>通过git bash提交代码到github时，如果没有设置的话，每次都需要输入用户名和密码，很麻烦对吧。但是可以通过设置省去每次提交时输入用户名和密码的过程。</p><h2 id="1-基于Https"><a href="#1-基于Https" class="headerlink" title="1. 基于Https"></a>1. 基于Https</h2><p>1.进入到你的<code>C:/Users/{你的电脑的用户名}</code></p><p>2.查看是否有一个<code>.gitconfig</code>文件</p><p>(1)如果有,打开文件, 查看里面的用户名和邮箱是不是你github的信息，不是,需要进行修改</p><p>(2)如果没有, 依次输入 <code>git config --global user.email &quot;你注册GitHub用的邮箱&quot;</code> 和 <code>git config --global user.name &quot;你GitHub的用户名&quot;</code>, 如果正常的话，会在本地生成一个对应的<code>.gitconfig</code>文件, 文件里面是你刚刚输入过的用户名好邮箱</p><p>3.在本地新建一个<code>.git-credentials</code>文件, 文件里面的内容为<code>https:{GitHub的用户名}:{GitHub的登录密码}@github.com</code></p><p>4.执行命令<code>git config --global credential.helper store</code>, 这是你的<code>.gitconfig</code>的内容应该是这样的<br><img src="https://s2.ax1x.com/2019/07/28/elOnkn.png" alt="Alt &#39;gitconfig的内容&#39;"></p><p>5.这时你进行提交时，还是会要你输入一串用户名好密码，输入后，后续的提交都可以免密提交了</p><h2 id="2-基于SSH"><a href="#2-基于SSH" class="headerlink" title="2. 基于SSH"></a>2. 基于SSH</h2><ol><li><p>同https方式的第一步</p></li><li><p>同https方式的第二步</p></li><li><p>查看本地有没有一个<code>.ssh</code>的文件夹，如果有,里面的文件有文件名为<code>id_rsa</code>和<code>id_rsa.pub</code>的请先进行处理，因为后续生成的用于登录github的密钥的名字冲突了(当然，你也可以直接使用这已有的公钥和密钥，前提是对你没有影响)</p></li><li><p>输入要命令 <code>ssh-keygen -t rsa -C 你注册GitHub用的邮箱</code>,期间的三次询问，默认回车就行了，最后你会发现你的本地生成了一个<code>.ssh</code>的文件夹，里面有2个文件<code>id_rsa</code>和<code>id_rsa.pub</code></p></li><li><p>登录你的github,<br>(1) 在首页点击你头像, 在下来的选项中点击<code>Settings</code>,<br>(2) 在左侧的侧边栏，选择<code>SSH and GPG keys</code>,<br>(3) 在右侧中, 选择 <code>New SSH key</code><br>(4) 打开你本地.ssh文件夹里面的<code>id_rsa.pub</code>,复制里面的全部内容<br>(5) 回到Github刚刚打开的页面，在里面的title栏，输入一个可以让你知道这个公钥的作用的提示就行了，然后把你复制的内容黏贴到下面的key栏，点击<code>Add SSH Key</code>就行了。</p></li><li><p>这样只要你后续不删除<code>.ssh</code>里面的内容，你就可以一直免密提交东西到github了。</p></li></ol><h2 id="3-备注"><a href="#3-备注" class="headerlink" title="3. 备注"></a>3. 备注</h2><ol><li><p>因为我的系统是window的，所以上面的2种方式都是cd 到了 <code>C:/Users/{你的电脑的用户名}</code>, 如果是Mac,应该是<code>/Users/username</code></p></li><li><p>2种方式要实现免密提交的大前提还有：你的仓库是使用对应的方式克隆下来的。如果你的仓库是通过https克隆下面的，那么ssh的免密提交是不起作用的，同理,ssh克隆下来的,https的方式不起作用<br><img src="https://s2.ax1x.com/2019/07/28/elx5Ps.png" alt="Alt &#39;https&#39;"> <img src="https://s2.ax1x.com/2019/07/28/elzSR1.png" alt="Alt &#39;SSH&#39;"></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 08:41:08 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;GitHub免密提交&quot;&gt;&lt;a href=&quot;#GitHub免密提交&quot; class=&quot;headerlink&quot; title=&quot;GitHub免
      
    
    </summary>
    
      <category term="Git" scheme="http://lcn29.github.io/categories/Git/"/>
    
      <category term="GitHub" scheme="http://lcn29.github.io/categories/Git/GitHub/"/>
    
    
      <category term="GitHub" scheme="http://lcn29.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Git提交撤销</title>
    <link href="http://lcn29.github.io/2019/08/04/Git%E6%8F%90%E4%BA%A4%E6%92%A4%E9%94%80/"/>
    <id>http://lcn29.github.io/2019/08/04/Git提交撤销/</id>
    <published>2019-08-04T04:58:23.000Z</published>
    <updated>2019-08-11T10:12:35.707Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 08:41:08 GMT+0800 (GMT+08:00) --><h1 id="Git提交撤销"><a href="#Git提交撤销" class="headerlink" title="Git提交撤销"></a>Git提交撤销</h1><p>把自己修改后的代码提交到远程的主干,通常需要经过 本地工作目录 -&gt; 暂存区 -&gt; 本地分支 -&gt; 远程分支。 其中第一个箭头就是<code>git add</code>,第二个表示<code>git commit</code>, 第三个箭头表示<code>git push</code>。我们需要经过这3步才能将我们做的修改发布到远程的分支。这三步如果有哪一步提交了，但是你又想撤销了，都可以通过对应的命令进行撤销</p><h2 id="git-add的撤销"><a href="#git-add的撤销" class="headerlink" title="git add的撤销"></a>git add的撤销</h2><p>(1) 需要撤销全部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure><p>(2) 只需要撤销某个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD 你想要撤销的文件</span><br></pre></td></tr></table></figure><h2 id="git-commit的撤销"><a href="#git-commit的撤销" class="headerlink" title="git commit的撤销"></a>git commit的撤销</h2><p>(1) 因为提交的备注错了,只需要修改备注</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行下面的命令,会进入到vim模式，可以执行对你的备注进行修改</span></span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>(2) 不删除工作空间改动代码, 撤销 commit, 同时撤销add</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD^</span><br><span class="line"><span class="comment"># 下面的效果和上面的一样</span></span><br><span class="line">git reset --mixed HEAD^</span><br></pre></td></tr></table></figure><p>(3) 不删除工作空间改动代码, 撤销 commit, 但是不撤销add</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure><p>(4) 删除工作空间改动代码(回到上次commit的样子)，撤销commit，撤销add</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>[注]上面的<code>HEAD^</code> 可以替代成<code>HEAD~1</code>,在 Git的1.8.5版本之后，HEAD有一个缩写形式@,既上面所有的<code>HEAD</code>都可以替换为<code>@</code></p><h2 id="git-push的撤销"><a href="#git-push的撤销" class="headerlink" title="git push的撤销"></a>git push的撤销</h2><p>情景： 现在有一个文件<code>a</code>,</p><ol><li>第一次在<code>a</code>里面写入<code>1</code>, push成功了,</li><li>第二次在<code>a</code>里面写入<code>2</code>, push也成功了,</li><li>第三次在<code>a</code>里面写入<code>3</code>, push成功了,<br>现在a的内容为’1,2,3’。</li></ol><ul><li>通过 git reset 进行撤销</li></ul><p>(1) 如果你现在只是想撤回3的提交,那么你可以直接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 git long 查找到2的提交id, 下面的命令可以加上参数 --oneline 减少一些没有的信息</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找到了，通过q退出查找</span></span><br><span class="line">q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚</span></span><br><span class="line">git reset 2的commitId</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制提交到远程分支</span></span><br><span class="line">git push origin 分支名 --force</span><br></pre></td></tr></table></figure><p>(2)如果想要撤回3,2的提交(同时撤销多个提交)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到 1处</span></span><br><span class="line">git reset 1的commitId</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把head重新移到最新的commitId, 这是你的内容还是1的内容,  没有这一步，后续的提交会报错</span></span><br><span class="line">git reset 远程分支最新的commitId</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>[注]reset 的三个参数(hard,soft,mixed)，根据自身的需要进行选择添加</p><ul><li>通过 git revert 进行撤销</li></ul><p>(1) 如果你现在只是想撤回3的提交,那么你可以直接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">q</span><br><span class="line"><span class="comment"># 此次的commitId为你想要撤销的Id，而不是下一个的commitId</span></span><br><span class="line">git revert 3处的commitId</span><br><span class="line"></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>(2)如果想要撤回3,2的提交(同时撤销多个提交)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">q</span><br><span class="line">git revert 3处的commitId 2处的commitId</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>[注]revert运行跨commit进行回滚的，前提的是你想要回滚的commit涉及的文件，在后面都没有被修改过</p><ul><li>revert和reset的区别</li></ul><blockquote><ol><li>revert是提交一个新的commit来回滚的, commit的内容就是和已想要回滚的那个commit相反的操作</li><li>reset 是直接删除指定的commit, 后续的commit记录是看不到的</li><li>上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突.但是revert 并不会</li><li>如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里</li><li>reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert<br>是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的</li></ol></blockquote><p>建议：用git revert来撤销已经提交的更改，而git reset用来撤销没有提交的更改</p><hr><p>参考：<br><a href="https://blog.csdn.net/qq_36460164/article/details/79857431" target="_blank" rel="noopener">git push之后回滚(撤销)代码</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 08:41:08 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Git提交撤销&quot;&gt;&lt;a href=&quot;#Git提交撤销&quot; class=&quot;headerlink&quot; title=&quot;Git提交撤销&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Git" scheme="http://lcn29.github.io/categories/Git/"/>
    
      <category term="GitHub" scheme="http://lcn29.github.io/categories/Git/GitHub/"/>
    
    
      <category term="GitHub" scheme="http://lcn29.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Git提交</title>
    <link href="http://lcn29.github.io/2019/08/04/Git%E6%8F%90%E4%BA%A4/"/>
    <id>http://lcn29.github.io/2019/08/04/Git提交/</id>
    <published>2019-08-04T01:33:49.000Z</published>
    <updated>2019-08-04T06:01:18.362Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 08:41:09 GMT+0800 (GMT+08:00) --><h1 id="Git提交"><a href="#Git提交" class="headerlink" title="Git提交"></a>Git提交</h1><h2 id="1-代码提交"><a href="#1-代码提交" class="headerlink" title="1. 代码提交"></a>1. 代码提交</h2><p>平时如果使用Github，没有按照客户端的话,或者借助开发工具(eclipse, idea等自带的插件),我们都是通过Git的控制台进行操作的，如果要提交代码的话, 我们需要依次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加当前路径和路径下面的所有修改过的文件</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'提交的备注'</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>我们可以通配置github免密提交，然后把上面的三个命令封装为一个shell脚本(也可以封装成window的cmd，可俺不会)，后续直接执行一次这个脚本,就能提交修改了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add . &amp;&amp; git commit -m <span class="variable">$1</span> &amp;&amp; git push</span><br></pre></td></tr></table></figure><p>新建一个<code>push.sh</code>文件，然后把上面的内容复制到文件内,然后把文件放到你的仓库的根目录,后续修改了代码，需要提交时只有打开git的bash 输入 <code>sh push.sh &#39;提交的备注&#39;</code>就行了</p><p>缺点：每次提交都是全部内容提交，没法做出筛选(可以修改一下脚本, 增加一个参数：提交的目录文件)</p><h2 id="2-将本地已有的代码提交到一个新的仓库"><a href="#2-将本地已有的代码提交到一个新的仓库" class="headerlink" title="2. 将本地已有的代码提交到一个新的仓库"></a>2. 将本地已有的代码提交到一个新的仓库</h2><p>如果你本地已有一部分写好的代码，现在想要用Github进行版本管理等，又不想改变本地的工作空间，那么你可以</p><blockquote><ol><li>在Github上新建一个仓库，仓库名和你本地代码的工作空间的名称一样,(如，你的代码在<code>D/code/project/Test</code>, test下面就是你想要提交到Github的内容,那么你的仓库名就是Test)</li><li>然后在你代码的根目录(也就是Test里面) 执行 <code>git init</code></li><li><code>git remote add origin 你的仓库地址</code> 把你本地和远程的git仓库绑定</li><li><code>git pull</code> 拉取远程仓库的内容</li><li><code>git add .</code> 把本地代码提交到git的缓存区 (如果有文件不想要提交的，提前建立好<code>.gitignore</code>文件进行过滤)</li><li><code>git commit -m &#39;提交备注&#39;</code></li><li><code>git push -u origin 你想要提交到的分支(master)</code> 提交到远程仓库</li></ol></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 08:41:09 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Git提交&quot;&gt;&lt;a href=&quot;#Git提交&quot; class=&quot;headerlink&quot; title=&quot;Git提交&quot;&gt;&lt;/a&gt;Git提交&lt;
      
    
    </summary>
    
      <category term="Git" scheme="http://lcn29.github.io/categories/Git/"/>
    
      <category term="GitHub" scheme="http://lcn29.github.io/categories/Git/GitHub/"/>
    
    
      <category term="GitHub" scheme="http://lcn29.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>GitHubPages介绍</title>
    <link href="http://lcn29.github.io/2019/08/01/GitHubPages%E4%BB%8B%E7%BB%8D/"/>
    <id>http://lcn29.github.io/2019/08/01/GitHubPages介绍/</id>
    <published>2019-08-01T12:00:32.000Z</published>
    <updated>2019-08-01T15:40:35.902Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Aug 26 2019 08:41:08 GMT+0800 (GMT+08:00) --><h1 id="GitHub-Pages介绍"><a href="#GitHub-Pages介绍" class="headerlink" title="GitHub Pages介绍"></a>GitHub Pages介绍</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Websites <span class="keyword">for</span> you and your projects.</span><br><span class="line">Hosted directly from your GitHub repository. Just edit, push, and your changes are live.</span><br></pre></td></tr></table></figure><p>我的理解：</p><ul><li>一个依托于Github仓库的展示你或者你的项目的静态网站。</li><li>当你的网站做了修改，只有将其托送到对应的Github仓库,那么你的修改就能立即生效。</li></ul><h2 id="2-展示你"><a href="#2-展示你" class="headerlink" title="2. 展示你"></a>2. 展示你</h2><p>基于GitHub Pages建立一个属于你自己的网站的步骤:</p><p>(1)第一步建立一个仓库<br>在Github上建立一个仓库，这个仓库和平时你存项目的仓库没有什么区别，唯一的要求就是仓库的名字的格式： <code>{你的Github用户名}.github.io</code> 这个格式是保证后续能够访问到你的仓库内容要求</p><p>(2)在你的仓库里面新建一个index.html页面(index.html就是你的网站的入口)</p><pre><code class="html"><span class="meta">&lt;!DOCTYPE html&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Examples<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello GitHub Pages !<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><p>通过上面2步上面，一个展示你的网站就完成了。这是你通过浏览器访问<code>https://{你的Github用户名}.github.io</code>你将看到你index里面的内容了: Hello GitHub Pages。</p><p>后续你只要修改index.html页面或者添加新的页面，在提交到你的仓库，那么对应的页面就会修改。所以你完全可以通过GitPage做一个你想要的网站</p><p>[注] 如果你拥有一个组织，也想建立一个展示你组织的网站,方式和上面类似，只是<code>{你的Github用户名}</code>修改为<code>{你的组织的名}</code></p><h2 id="3-展示你项目"><a href="#3-展示你项目" class="headerlink" title="3. 展示你项目"></a>3. 展示你项目</h2><p>假设你把你的一个项目托管到了github,并将其开源了。那么为了让别人能开心的使用你的开源项目，当前需要有对应的说明文档吧。这是你会?</p><blockquote><ol><li>直接写在readme</li><li>开一个wiki</li></ol></blockquote><p>这2种方式都可以。 现在你可以多一种方式了：为你的项目建一个GitHub Pages,通过网页的形式进行介绍</p><ul><li>第一步在你的开源项目下新建一个分支 (分支名：gh-pages)</li><li>在你的分支里面放入你想要展示的页面(如果你的项目的master里面原本是有内容的，切的分支里面也会有对应的内容,因为这条分支后续是不会合并内容到主干的，所以可考虑把这些内容删除,方便后续的管理)</li></ul><p>这时你就可以通过 <code>https://{你的用户名}.github.io/{你的项目仓库名(大小写要一致)}</code>访问到你的项目了GitHub Pages了</p><h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h2><p>GitHub Pages 网站是在网络上公开使用的，即使他们的库是私有的。如果你敏感的数据在你的Page库中，你可能需要在发布之前删除它</p><h2 id="5-使用限制"><a href="#5-使用限制" class="headerlink" title="5. 使用限制"></a>5. 使用限制</h2><blockquote><ol><li>GitHub Pages源库建议限制在1GB内</li><li>发布的GitHub Pages网站体积最大不能超过1GB,(还有每个月限制100000的访问量,但是从<a href="https://help.github.com/en/articles/what-is-github-pages" target="_blank" rel="noopener">官网</a>来看的话，这个限制应该是没有了)</li><li>GitHub Page网站带宽限制是100Gb</li><li>GitHub Pages页面网站每小时最多有10次构建</li></ol></blockquote><p>如果你超过了这些使用配额，Github官方将不会提供给你的网站提供服务，或者你可能会受到一个有礼貌的邮件，它是来自GitHub Support的建议策略，目的是降低你的网站对GitHub服务器的影响。建议其中包括迁移到一个不同的主机服务以便更加满足你的需求。</p><h2 id="6-禁止事项"><a href="#6-禁止事项" class="headerlink" title="6.禁止事项"></a>6.禁止事项</h2><blockquote><ol><li>GitHub的服务条款禁止的或非法的内容或活动</li><li>暴力或威胁性的内容或活动</li><li>过多的自动化批量活动(例如，垃圾邮件)</li><li>危害github用户或github服务的活动</li><li>快速致富计划,也就是赌博等活动</li><li>色情内容</li><li>歪曲你的身份或网站目的的内容</li></ol></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Aug 26 2019 08:41:08 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;GitHub-Pages介绍&quot;&gt;&lt;a href=&quot;#GitHub-Pages介绍&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Git" scheme="http://lcn29.github.io/categories/Git/"/>
    
      <category term="GitHub" scheme="http://lcn29.github.io/categories/Git/GitHub/"/>
    
    
      <category term="GitHub" scheme="http://lcn29.github.io/tags/GitHub/"/>
    
  </entry>
  
</feed>
