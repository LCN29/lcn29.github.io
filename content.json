{"meta":{"title":"lcn的博客","subtitle":"学无止境","description":"好记性不如烂笔头","author":"lcn","url":"http://lcn29.github.io","root":"/"},"pages":[{"title":"404 Not Found","text":"","path":"/404.html","date":"07-12","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"07-13","excerpt":""},{"title":"关于我","text":"","path":"about/index.html","date":"07-13","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-12","excerpt":""},{"title":"文章分类","text":"","path":"categories/index.html","date":"07-13","excerpt":""}],"posts":[{"title":"HashSet","text":"HashSetHashSet 内部是通过 HashMap 实现的，所以了解HashSet, 之前应该有一点 HashMap 的知识的, 可以简单的看一下这个。创建123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class HashSet&lt;E&gt; &#123; /** * 用 HashMap 存放数据， 其中key就是我们的map的key * value 统一为下面的PRESENT * */ private transient HashMap&lt;E,Object&gt; map; // map中键对应的value值 private static final Object PRESENT = new Object(); /** * 无参 */ public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; /** * 直接放入一个 Collection */ public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; /** * 指定容量 和 负载因子 */ public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor); &#125; /** * 指定容量 */ public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity); &#125; /** * 这个方法, 基本可以看作抛弃的方法 */ HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; /** * 放入全部 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified; &#125; /** * 把数据存到 map 的key中 */ public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125;&#125;通过上面的代码, 我们可以发现:HashSet是基于HashMap实现的, 我们存入的值，作为map的key, 而value都是统一为一个Object对象 PRESENT增123456789public class HashSet&lt;E&gt; &#123; /** * 把对象当做key, 调用hashMap 的 put方法 */ public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125;&#125;删123456789public class HashSet&lt;E&gt; &#123; /** * 把对象当做key, 调用hashMap 的 remove方法 */ public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125;&#125;查Set 比较特殊, 没有提供直接获取值的方法 get(),同时也没必要, 如果你有一个值 a, Set.get(参数), 这个参数填什么? 你是期望从Set中获取到 a 吗？, 如果单纯的是想判断已对象是否存在，可以通过 contain 进行判断。HashSet 的补充1) 因为 HashSet 是通过 HashMap 实现的, HashMap 的 key 可以存null, 但是只能存一个, 所以 HashSet 支持存null, 同时只能存一个2）因为 HashMap 是非线程安全的，所以 HashSet 也是线程非安全的。3）HashSet 也是自定义了序列化方法4) HashSet 内部没有提供自己的迭代器, 他内部是通过 HashMap 的 key迭代器实现的5）HashMap 支持 fail-fast 机制, 理所当然的 HashSet 也是。6）HashSet 的数据是无序的","path":"2019/08/20/HashSet/","date":"08-20","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://lcn29.github.io/tags/Java/"}]},{"title":"HashMap","text":"HashMapJDK1.8 对 HashMap 进行了比较大的优化, 底层实现由之前的 “数组 + 链表” 改为 “数组 + 链表 + 红黑树”。 在链表的长度大于等于8并且数组的长度大于等于64时,将这个链表转为红黑树所以在继续下去之前, 先确保一下, 你对红黑树(本质是一颗二叉排序树)有一点的了解。 可以看一下这几篇文章, 做一下入门。清晰理解红黑树的演变—红黑的含义 红黑树的前身教你初步了解红黑树 红黑树的节点插入红黑树之删除节点 红黑树的节点删除红黑树原理以及插入、删除算法 附图例说明 里面的增删图片不错上面几篇文章是我在学习红黑树是看的, 感觉质量挺不错的，起码我是看懂了。 当然如果你已经都红黑树有一定的了解了，那么我们直接开始吧。入门前介绍一下在 HashMap 中, 一开始存储数据的数组的类型是链表，链表的声明如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class HashMap &#123; /** * 实体类 */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 当前节点的hash final int hash; // 当前节点的 key final K key; // 当前节点的 value V value; // 下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; public final int hashCode() &#123; // Objects.hashCode 本质就是调用对象的 o.hashCode() // 当前节点的hashCode 值 是 key的hashCode 异或 value的hashCode 值 return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; /** * 节点比较 */ public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; // Objects.equals 会 先比较一下 2者的内存地址， 一样直接返回true // 不一样，调用 key.equals(e.getKey) 进行比较 if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125;&#125;在 HashMap 中, 一开始存储数据的数组的类型是链表，在一定情况下, 会转为红黑树, 定义如下12345678910111213141516171819public class HashMap &#123; // 继承了 LinkedHashMap.Entry, Entry 继承了 HashMap.Node 所以 TreeNode 具有 链表的特点 static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; // ... 后面 省略 红黑树的操作 &#125;&#125;HashMap的创建123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350public class HashMap &#123; // -Djava.lang.Integer.IntegerCache.high=250 // HashMap 最大的容量 2^30 既 01 + 30个0 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 负载因子： 默认为0.75 // 作用： 在ArrayList 中 通常都是在数组满了才会进行扩容, 但是在HashMap中, 数据量达到了数组的长度 * 负载因子的值，就进行扩容 // 原因： hashMap 在数组中插入一个数据，是先通过一个hash方法转为到数组的一个位置, 通过Hash就可能存在hash冲突, // 数据越密集，冲突的可能性越大, 所以 hashMap 中的数组是不会完成存满的, 通过空留一部分, 减少冲突等 // 负载因子 默认值为 0.75 的原因： 太多的话，冲突可能性变大，太小浪费了空间，同时会导致数组扩容等耗时操作, 所以 0.75 应该是一个经验值的估算, // 或者 是因为 HashMap的数组长度为 2^n, 乘以 0.75, 能获得一个整数吧 final float loadFactor; // 用来当前数组的阈值, 实际应该放多少数据, private int threshold; // 存放数据的地方 transient Node&lt;K,V&gt;[] table; /** 无参的构造函数 */ public HashMap() &#123; // 设置了负载因子为默认值： 0.75, 其他的属性默认 this.loadFactor = DEFAULT_LOAD_FACTOR; &#125; /** * 指定容量的初始 */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** 指定初始容量 和 负载因子 */ public HashMap(int initialCapacity, float loadFactor) &#123; // 格式不正确 if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); // 设置最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 格式不正确 isNaN(arg) =&gt; arg 不是数字，返回true if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; // 此次的阈值 为 2的n次方, 实际应该是 2^n * 负载因子, 这里会在你第一次放数据时，进行修正，只是这里刚刚用它来存数组实际需要的容量 this.threshold = tableSizeFor(initialCapacity); &#125; /** * 指定 Map的的创建 */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; /** * 计算负载，也就是数组当前的容量 */ static final int tableSizeFor(int cap) &#123; // 此次减1的原因时，让后面基本处理处理的结果变为 n是第一个大于等于cap的 2的n次方的数 // 如果这里不减 1 的话， 我们刚好传进来的数是 2的n次方, 经过下面几步的处理会变成 2的n+1次方 int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; // 做一个容错 如果 cap 是一个 大于 2^31 的正数, 经过上面的处理, 次数 n会变为负数 // n为负数了，直接设置为1 return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; /** * 放入数据 * @param m 数据 * @param evict */ final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; // 当前存放数据的 table 为空 if (table == null) &#123; // 计算出来需要的容量 = 长度 / 赋值因子 + 1 float ft = ((float)s / loadFactor) + 1.0F; // 限制最大的容量 为 2^ 31 int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 计算出来的当前需要的容量 &gt; 实际的容量，进行新容量的计算 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) // 当前存入的数据量 直接大于当前阈值，进行重新扩容 resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125; &#125; /** * 存值 * @ hash 存的可以的hash值 * @ key 对象的key * @ value 存的值 * @ onlyIfAbsent 存入的节点已在hashMap中存在， 是否有新的value替代 旧的 value false进行修改, true不修改 * @ evict 这个值用于 LinkedHashMap 在HashMap 中没有作用 */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 数组为空 或者 数组的长度为 0, 进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // hashMap 对象的位置 是通过 (数组的长度 - 1) &amp; hash, 也就是 hash % 2 ^ n // 指定为位置为空，直接将他放到指定的位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 需要放入的位置的第一个节点 的 hash 和 key 一样，取到这个节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) // 调用红黑树 进行处理 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; // 从链表的第一个节点开始遍历到尾部 // 下一个节点为空, 直接将当前的节点放到尾部 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 当前的容量 已经达到了 8个, 转为 红黑树, 这个方法这里没有介绍 if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); break; &#125; // 链表中有一个节点的hash 和 key 和要插入的一样，取到这个节点 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; V oldValue = e.value; // 新值 替换旧值 if (!onlyIfAbsent || oldValue == null) e.value = value; // HashMap的这个方法 没有实现 afterNodeAccess(e); return oldValue; &#125; // 用于支持 fast-fail 机制 ++modCount; // 达到了阈值，进行扩容 if (++size &gt; threshold) resize(); // HashMap的这个方法 没有实现 afterNodeInsertion(evict); return null; &#125; &#125; /** * 计算对象的hash值 */ static final int hash(Object key) &#123; int h; // 对象的hashCode ^ 对象的hashCode &gt;&gt;&gt; 16 // 将hashCode的高16位与hashCode进行异或运算，主要是为了在table的length较小的时候，让高位也参与运算，并且不会有太大的开销 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; /** * 重新扩容 */ final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; // 当前的容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; // 当前的阈值 int oldThr = threshold; // 新的容量，新的阈值 int newCap, newThr = 0; // 当前的容量不为0, 也就是有数据存在了 if (oldCap &gt; 0) &#123; // 当前的容量已经达到最大了，直接不进行操作 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 直接将阈值设为int 的最大值 // 实际的数组长度为 2^30 现在直接把阈值变为了 (2^31 - 1), 应该是为了能够利用还剩余的空间吧 threshold = Integer.MAX_VALUE; return oldTab; // 新的容量 = 旧的容量 * 2 新的容量 &lt; 最大容量 &amp;&amp; 旧的容量 &gt;= 初始默认的容量(16) 直接设置新的负载 = 旧的 * 2 // oldCap &gt;= DEFAULT_INITIAL_CAPACITY 的 作用 看下面的 备注1 &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; &#125; else if (oldThr &gt; 0) // 当旧的阈值大于 0, 设置 新的容量 = 阈值 // 能够走到这一步的情况有： // 1. 我们初始时，只指定了容量， 然后第一次往里面加数据 // 2. 初始时, 只传递了一个Map, 然后第一次把Map里面的数据放到当前HashMap时 newCap = oldThr; else &#123; // 当我们创建时, 没有指定容量时, 在第一次放数据，会走这一步进行容量的设置 默认时 16, 阈值为 16 * 0.75 // 能够走到这一步的情况有： // 我们初始时, 没有指定任何参数 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; // 计算 阈值 = 新容量 * 0.75, 如果 阈值超过了最大容量, 则直接设置为 int的最大值 // 能够走到这一步的情况有： // 1. 我们初始时，只指定了容量， 然后第一次往里面加数据 // 2. 初始时, 只传递了一个Map, 然后第一次把Map里面的数据放到当前HashMap时 // 3. 扩容时, 新的容量 &lt; 32 这一种情况，需要结合上面的扩容的 oldCap &gt;= DEFAULT_INITIAL_CAPACITY 进行分析 float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // 设置新的阈值 threshold = newThr; Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 数组 重新赋值 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; // 获取到当前数组的第 j个元素 if ((e = oldTab[j]) != null) &#123; // 旧的值设置为空, 方便垃圾回收 oldTab[j] = null; if (e.next == null) // 如果e.next为空, 则代表旧数组的该位置只有1个节点, 那么把这个节点直接放到新数组里面，就行了 // 通过 (节点 的 hash 值 &amp; 新容量 -1 ) 取到新的位置 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) // 原本的这个节点为 树节点, 调用TreeNode的split进行处理 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 声明了2个链表 lo链表, hi链表, 同时声明了4个指针, 分别指向了2个链表的头和尾 // 其中的 lo 可以理解为 low, hi 为 hight, 新的数组 是原来的2倍， 那么 原来的一倍 可以理解为 low, 扩充出来的为 hight // 而原本在同一个链表上的节点, 在后面的扩容， 会被分配到2个地方 和原来一样的index, 或者 index + oldCap // lo链表 存放的是 节点位置不需要修改的节点 Node&lt;K,V&gt; loHead = null, loTail = null; // hi链表 存放的是 节点位置需要修改的节点， 这里的位置变为了 index + oldCap, Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; // 下一个节点 next = e.next; // 这一步的判断： 判断节点在新数组的位置是否和在旧数组的一样 等于0 表示一样。 // 原理看一下 备注2 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) // 如果loTail为空, 代表该节点为第一个节点 loHead = e; else // 否则将节点添加在链表的尾部 loTail.next = e; // 重新设置尾结点 loTail = e; &#125; else &#123; if (hiTail == null) // 作用同上面 hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; // 设置数组的 j位置 为 lo链表 loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; // 设置数组 的 j + oldCap 为 hi链表 hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; /** * 将指定的位置转为树 */ final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; // 数组为空， 长度还不够 64, 进行扩容, 不进行转换操作 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); // 需要处理的位置的链表不为null else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; // 因为 TreeNode 继承了 Node, 所以 TreeNode 也可以当做链表使用 // 将Node 转为 TreeNode // 然后将下面拼接成 一个以 TreeNode 为类型的 链表 TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) // 树的根节点 hd = p; else &#123; // 按照链表的格式, 改变节点的指向, p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); // 重新将当前节点头结点设置为 树的根节点 if ((tab[index] = hd) != null) // 转为树 hd.treeify(tab); &#125; &#125; TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next); &#125;&#125;备注 1:在 resize方法中, 旧数组已有数据了, 但是在进行扩容时, 容量默认是2倍扩展，但是阈值只有在 oldCap &gt;= DEFAULT_INITIAL_CAPACITY 时才会进行2倍扩展, 否则是以 新的容量 * 负载因子, 原因：为了在容量少的情况下，尽可能的利用数组的空间，不造成浪费。假设我们在初始时，指定了容量为2, 那么在初始后 容量值为 2, 阈值为 * 0.75 = 1。第一次扩容：| | 旧的容量 |新的容量 |旧的阈值| 经过运算新的阈值 || :-: | :-: | :-: | :-: | :-: || 旧阈值 &lt;&lt; 1 | 2 | 4 | 1 | 2 || 新容量 × 0.75 | 2 | 4 | 1 | 3 |第一次扩容：| | 旧的容量 |新的容量 |旧的阈值| 经过运算新的阈值 || :-: | :-: | :-: | :-: | :-: || 旧阈值 &lt;&lt; 1 | 4 | 8 | 2 | 4 || 新容量 × 0.75 | 4 | 8 | 3 | 6 |第三次扩容| | 旧的容量 |新的容量 |旧的阈值| 经过运算新的阈值 || :-: | :-: | :-: | :-: | :-: || 旧阈值 &lt;&lt; 1 | 8 | 16 | 4 | 8 || 新容量 × 0.75 | 8 | 16 | 6 | 12 |第四次扩容| | 旧的容量 |新的容量 |旧的阈值| 经过运算新的阈值 || :-: | :-: | :-: | :-: | :-: || 旧阈值 &lt;&lt; 1 | 16 | 32 | 8 | 16 || 新容量 × 0.75 | 16 | 32 | 12 | 24 |通过上面可以发现：在旧容量 &lt; 16 之间变化时, 通过 新容量 × 负载因子, 阈值会大一些, 可以更充分的理由数组的空间, 在第四次扩容时, 旧的阈值为12, 新容量为32时，这时12 &lt;&lt; 1 等于 32 * 0.75, 所以2者后续的计算是一样的，通过位运算比较快。备注 2：(e.hash &amp; oldCap) == 0 可以判断节点在新数组的位置和旧数组的是否一样。 能达到这样的效果的必须知道：oldCap 是 2 ^ n, newCap 是 在 oldCap的基础 * 2, 也就是 newCap 是 2 ^ (n + 1)2 ^ n 在二进制的表示为 1 + n个0 , 2 ^ (n + 1) 二进制表示 1 + (n+1)个02 ^ n - 1 在二进制的表示为 n 个 1, 那么 2 ^ (n + 1) 就是 n + 1 个 1(2 ^ n - 1) &amp; hash 我们只需要取hash的1到n位就行了, 因为 2 ^ n - 1 前面都是 01) 我们假设 现在 oldCap是16,既 2^4, 16 - 1 = 15, 二进制表示为 00000000 00000000 00000000 000011112) (16-1) &amp; hash 自然就是取hash值的低4位, 我们假设它为 abcd3) oldCap扩大了一倍, 新的index的位置就变成了 (32-1) &amp; hash, 就是取 hash值的低5位, 那么对于同一个Node, 低5位的值无外乎下面两种情况: 0abcd 或者 1abcd4）0abcd = index, 而 1abcd = 0abcd + 10000 = 0abcd + oldCap = index + oldCap, 从这里可以知道 容量扩大了一倍, 那么 新的index是有规律的, 要么不变, 要么就是 index + oldCap5) 新旧index是否一致就体现在hash值的第5位, 那么第5位怎么知道呢？ 这时我们可以知道 2^n 的二进制形式 1 + 5个0, 那么 hash &amp; oldCap 就能知道 hash 的第5位 是0 或者 16） hash &amp; oldCap = 0 =&gt; 当前节点在数组的位置不用变, hash &amp; oldCap != 0 =&gt; 当前节点在新数组的 index + oldCap 的位置查1234567891011121314151617181920212223242526272829303132333435363738394041public class HashMap &#123; /** * 通过 key 获取value, 如果 节点为null, 返回nulL */ public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; /** * 通过key的 hash 和 key 获取对应的节点 */ final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 数组不为空，长度大于 0 ， 链表的第一个节点 不为 null if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 第一个节点 符合条件了, 直接返回 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 有下一个节点 if ((e = first.next) != null) &#123; if (first instanceof TreeNode) // 树节点 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; // 遍历 链表的其他节点, if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; // 没找到 直接返回 return null; &#125;&#125;增1234567891011public class HashMap &#123; /** * 存入新值 */ public V put(K key, V value) &#123; // 查看上面的 putVal方法 return putVal(hash(key), key, value, false, true); &#125;&#125;删除12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class HashMap &#123; /** * 直接通过 key删除 */ public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; &#125; /** * 通过key 和 内容 进行删除 */ public boolean remove(Object key, Object value) &#123; return removeNode(hash(key), key, value, true, true) != null; &#125; /** * 删除节点 * matchValue : 为 true，找到了节点，还会比较他们的值，值相同才会删除 * movable : 为false, 蛋节点删除了, 不改变其他节点的位置 */ final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; // 数组不为null, 长度大于 0，同时定位到的位置 不为 null if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; // 链表的第一个节点，的情况符合了 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; // 链表的下一个节点不为null else if ((e = p.next) != null) &#123; // 节点为 树节点 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; // 遍历链表 do &#123; // 寻找找到符合条件 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; // 找到了需要的节点 如果设置了需要检查值, 后面会对其值的内存地址和equals进行比较 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) // 调用红黑树的删除节点的方法 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) // 把 链表的头部直接指向了下一个节点 tab[index] = node.next; else // p的下一个节点指向需要删除节点的下一个节点 p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null; &#125;&#125;HashMap的总结HashMap 中的数组都是2的幂次方, 最大上限为 2^30每个存到HashMap中的 key, value 都会被封装到为 Node, Node 里面有一个 hash值, 这个值可以定位到他在数组的位置 (hash &amp; (数组的长度 - 1), 这里相当于 hash % 数组的长度), 同时可以知道他在链表或者树中的位置, 这个值的计算(key = key.hashCode()) ^ (key &gt;&gt;&gt; 16)HashMap 中链表向红黑树的转换 的时机： 数组的长度大于等于 64, 同时 链表的长度 &gt;= 8HashMap 中红黑树可以转换为链表, 时机： 红黑树中的节点数小于等于 6, 会由 红黑树转为链表, 具体代码可以看一下 HashMap.TreeNode.splitHashMap 中的阈值在 当前容量 小于32, 都是等于 当前容量 * 负载因子, 大于等于32, 等于12(当容量为16时, 16 * 负载因子, 默认0.75) * 2通过对put 的分析，我们可以知道, HashMap.put(null, value) 是可以的, 此时key的hashCode为0, 但是key值需要唯一，所以HashMap, 只能存一个key为 null 的值,HashMap 默认的初始容量为 16, 负载因子为 0.75, 其中指定的容量不是2的n次方的话，会转换为大于等于这个值的2的n次方, 还有负载因子如果没有必要，尽量不要去修改get的过程通过key 获取到对应的hashCode (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)同hashCode &amp; 数组的长度, 得到他在数组中的位置遍历对应位置的链表或者树, 通过 e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))) 进行比较, 如果为true, 就一样的。依次比较的内容, 2个key 的hashCode 一定要一样hashCode 一样了, 如果内存地址一样, 那么一样hashCode 一样了，内存地址不一样, 在通过 equals 比较一次, (正常情况下这个是直接调用Object.eqhals方法, 还是比较的是2个对象的内存地址, 但是如果你重新了,那么就用你重新的方法)HashMap的补充HashMap 同样是线程不安全的, 如果需要线程安全，同样可以通过 Collections.synchronizedMap() 获取到一个线程安全的实现类。HashMap 支持 fail-fast机制HashMap 的序列化也是自定义的HashMap 内部提供了许多迭代器: KeyIterator, ValueIterator, EntryIteratorHashMap 的线程不安全, 猜测时, 同时有2个线程判断到需要扩容了, 然后同时进行扩容, 期间就可能造成闭合的链路。参考Java集合：HashMap详解（JDK 1.8）深入理解HashMap(四): 关键源码逐行分析之resize扩容","path":"2019/08/20/HashMap/","date":"08-20","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://lcn29.github.io/tags/Java/"}]},{"title":"ArrayDeque","text":"ArrayDequeArrayDequeArrayDeque是一个基于数组实现的双端队列(double-ended-queue)。 Deque接口除了提供操作双端队列的一系列方法之外，还提供了操作栈的方法，因此ArrayDeque也可以表示一个栈。基于数组实现队列时, 我们添加数据时, 可以直接在尾部添加了数据，但是如果我们要取数据呢，我们把第一个取出来后，后面的数据都往前移一位, 这是一个很费时的操作。 为了解决这个问题, 我们引入了2个索引, 一个指向了头, 另一个指向了数组有效数据的后一位(第一个空位), 这样我们取的时候, 头部置为空，然后头指针往后移一位。 添加时, 如果尾指针已经到了最后一位, 那么重新到数组的头部查找, 放到头部。 最后通过判断头尾指针是否一样，来决定是否要扩容。结构图:操作方法offer系列add系列方法描述offerFirst()addFirst()将指定的元素插入到队首offerLast()addLast()将指定的元素添加到队尾pollFirst()removeFirst()取出并删除队首的元素pollLast()removeLast()取出并删除队尾的元素peekFirst()getFirst()取出队首的元素，但不删除peekLast()getLast()取出队尾的元素，但不删除它们的区别是：offer系列方法在操作失败时会返回一个特殊值（根据操作的不同，为false或者null）；add系列方法在操作失败时会抛出异常。ArrayDeque的创建123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157public class ArrayDeque &#123; transient Object[] elements; // 队首元素的索引 transient int head; // 队尾的下一个索引 transient int tail; private static final int MIN_INITIAL_CAPACITY = 8; /** * 无参 */ public ArrayDeque() &#123; // 没有指定容量, 默认为2^4 16 // arrayDeque 的容量设置为都是2的n次方, 是为了方便后续的操作 elements = new Object[16]; &#125; /** * 指定容量 */ public ArrayDeque(int numElements) &#123; // 指定了大小, 会根据你传入的值, 扩大到第一个大于你传入的值的2的n次方 allocateElements(numElements); &#125; /** * 传递集合 */ public ArrayDeque(Collection&lt;? extends E&gt; c) &#123; // 根据 出入的 Collection的大小，进行扩容 allocateElements(c.size()); // 添加c到数组中 addAll(c); &#125; /** * 创建对象 */ private void allocateElements(int numElements) &#123; elements = new Object[calculateSize(numElements)]; &#125; /** * 计算容量 */ private static int calculateSize(int numElements) &#123; // MIN_INITIAL_CAPACITY = 8; // 从这里可以看出 ArrayDeque的最小容量 为8 int initialCapacity = MIN_INITIAL_CAPACITY; if (numElements &gt;= initialCapacity) &#123; initialCapacity = numElements; // &gt;&gt;&gt; 无符号 右移 =&gt; 右移后，最高位直接取0 // 经过下面的6步 可以将 initialCapacity 变成 第一个大于 numElements的2的n次方 // 要理解下面的算法，有一点认识： // 第一： 2^n 二进制的形式为: 从1到n位 都是0, 第n+1位为1 // 如 (int)256 2^8 =&gt; 00000000 00000000 00000001 00000000 // 第二： 那么 2^n - 1 就能推出 =&gt; 从1到n-1位 都是1 第n位为0, // 255 =&gt; 00000000 00000000 00000000 11111111 // 设 initialCapacity 转为2进制后, 有效的位算为x位, //既从右往左算到最后一个1的长度, 如上面的 256, x就是9, 255, x就是8 // 第一步: initialCapacity二进制 表示 =&gt; 1 + (x-1 个 0/1), // initialCapacity &gt;&gt;&gt; 1 =&gt; 01 + (x-2 个 0/1), //或(|)运算后 =&gt; 11(x-2 个 0/1) =&gt; initialCapacity的有效位的前2位都为1了 // 第二步: initialCapacity =&gt; 11(x-2 个 0/1), // initialCapacity &gt;&gt;&gt; 2 =&gt; 0011(x-4 个 0/1), |运算后 =&gt; 1111（x-4 个 0/1）=&gt; 前4位都为1了 // ... // 经过了前 5 步 initialCapacity 变成了 1(x-1 个 1) // 第6步 + 1 initialCapacity 变成了 1(x个0) 也就是变成了 2 ^ initialCapacity的有效位 也就是变成了 2^n initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; // 做一个容错, 如果 numElements很大的时候，经过位运算 会变成负的 // 可以推导出 numElements的值 &gt;= 2^30 时, 就会变为负 // 2^30 的二进制 =&gt; 01000000 00000000 00000000 00000000 (int的长度为32位) // 经过上面的 上面的前 5步 initialCapacity=&gt; 01111111 11111111 11111111 11111111 // 在经过 第 6步, initialCapacity=&gt; 10000000 00000000 00000000 00000000 =&gt; -2147483648 变成了负了 // 这时在将 initialCapacity 右移1位，转为正的 initialCapacity &gt;&gt;&gt;= 1 =&gt; 01000000 00000000 00000000 00000000 // 最终可以得出 ArrayDeque 的最大容量为 1073741824 2^31 if (initialCapacity &lt; 0) // 最大的容量 2^30个 元素 initialCapacity &gt;&gt;&gt;= 1; &#125; return initialCapacity; &#125; /* * 使用的是父类 AbstractCollection的addAll方法 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified; &#125; /** * 添加元素 默认添加到后面 */ public boolean add(E e) &#123; addLast(e); return true; &#125; /** * 将元素添加到最后面 */ public void addLast(E e) &#123; // ArrayDeque不允许放入null if (e == null) throw new NullPointerException(); // 添加到后面 elements[tail] = e; // 尾部指针往后 + 1 判断是否需要扩容 // 下面的 a &amp; (b -1) 当 b为 2^n, 同时 a &gt; 0 的情况下 a&amp;(b-1) 效果等同于 a%b(取模) // 头和尾指针一样, 容量满了， 进行扩容 if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); &#125; /** * 扩容 */ private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; // 头指针右边的数量 int r = n - p; // 扩容 变为原来的2倍 int newCapacity = n &lt;&lt; 1; if (newCapacity &lt; 0) throw new IllegalStateException(\"Sorry, deque too big\"); Object[] a = new Object[newCapacity]; // 把原本的右边的放到a的开始位置 System.arraycopy(elements, p, a, 0, r); // 把左边的放到了 a 的r的位置 System.arraycopy(elements, 0, a, r, p); elements = a; head = 0; tail = n; &#125;&#125;添加12345678910111213141516171819202122232425262728293031323334353637/** * 放到头部 */public boolean offerFirst(E e) &#123; addFirst(e); return true;&#125;/** * 放到头部 */public void addFirst(E e) &#123; if (e == null) throw new NullPointerException(); // head的取值 [0, elements.length - 1], head - 1 =&gt; [-1, elements.length - 2], // 如果 head为 -1， 二进制为 11111111 11111111 11111111 11111111 // 这样, 当 head -1 为 -1时，通过 &amp; 得到的值 就是elements.length - 1, 回到了数组的最后的一位了。 // 当 head -1 &gt;= 0, 那么就是 相当于取模, 同时 head 一定不会大于 elements.length, // 所以 结果就是 head - 1的值, 也就是让head前进一位， // 所以下面的方法, 使得 head = 0 时， head = elements.lenght head &gt;0, head = head -1; // 最终 形成了一个循环 elements[head = (head - 1) &amp; (elements.length - 1)] = e; if (head == tail) doubleCapacity();&#125;/** * 追加到后面 */public boolean offerLast(E e) &#123; // 看上面的构造方法 addLast(e); return true;&#125;删除1234567891011121314151617181920212223242526272829303132/** * 取出并删除队首的元素 */public E pollFirst() &#123; int h = head; E result = (E) elements[h]; if (result == null) return null; elements[h] = null; // 此次相当于取模 (h + 1) % elements.lenght 当 h已经是队尾了，可以回到头部 head = (h + 1) &amp; (elements.length - 1); return result;&#125;/** * 取出并删除队首元素 */public E pollLast() &#123; // 此次的原理 同 addFirst() int t = (tail - 1) &amp; (elements.length - 1); E result = (E) elements[t]; if (result == null) return null; elements[t] = null; tail = t; return result;&#125;获取123456789101112131415/** * 取出队首的元素，但不删除 */public E peekFirst() &#123; return (E) elements[head];&#125;/** * 取出队尾的元素，但不删除 */public E peekLast() &#123; // 因为默认 tail 不是指向 尾元素，而是尾元素的后一个元素, 所以需要计算一下 return (E) elements[(tail - 1) &amp; (elements.length - 1)];&#125;补充ArrayDeque 是一个线程不安全的集合ArrayDeque 不允许存放null元素ArrayDeque 不仅可以作为双端队列使用，还可以当做栈使用, 官方也是推荐的，里面还提供对应的操作 push, popArrayDeque 也是自己重写了序列化和发序列化方法ArrayDeque 当用作栈时，性能优于Stack，当用于队列时，性能优于LinkedListArrayDeque 也是支持fail-fast机制, 内部自己实现了Iterator接口, 当是他用的不是modCount, 而是自身的指针tail，每次遍历时判断当前的tail是否修改过了，是的话直接扔 ConcurrentModificationExceptionArrayDeque 内部还实现了一个 DescendingIterator 的迭代器，可以用于从尾部遍历到头部","path":"2019/08/17/ArrayDeque/","date":"08-17","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://lcn29.github.io/tags/Java/"}]},{"title":"LinkedList","text":"LinkedList链表LinkedList 是基于 双向链表实现的。单链表, 双链表, 循环链表的定义, 可以看一下这个链表内存是散乱的, 每一个元素存储本身内存地址的同时还存储下一个元素的地址链表具备了增删快, 查找慢的特点LinkedList 是基于双向链表设计的, 所以具备了链表的特点LinkedList结构图:LinkedList的创建123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143public class LinkedList&lt;E&gt; &#123; /** 当前的数据个数 */ transient int size = 0; /** Node是LinkedList的一个内部类 第一个节点 */ transient Node&lt;E&gt; first; /** 最后一个节点 */ transient Node&lt;E&gt; last; /** * LinkedList 内部类 */ private static class Node&lt;E&gt; &#123; /** 当前节点的内容 */ E item; /** 下一个节点 */ Node&lt;E&gt; next; /** 上一个节点 */ Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; public LinkedList() &#123; &#125; /** * 给定集合创建 */ public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; /** * 从指定位置, 批量添加元素 * 下面的方法可以分成这几个 * 1. 当前的数据都为null, 那次c中的第一个数据，封装成node, node的pre为空, 将LinkedList的first设置为这个node, 后面的数据依次拼在node的后面 * 2. 已有数据，新增的数据追加在已有数据的最后面, 直接拼在最后就行了 * 3，已有数据，新增数据插在已有的中间, 把已有数据安装需要插入的位置分成2部分， A, B, 把新增的数据 先拼到A的后面， 然后把B在拼到新的A的后面 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; // pred: 新增的元素的将要插入的位置的前一个节点 succ: 新增的元素的将要插入的位置的节点 // 假设 新增的元素的位置为a, 那么 pred 就是 a的前一位的节点, succ 就是a节点 Node&lt;E&gt; pred, succ; // 需要添加的元素刚好追加在已有的后面的 if (index == size) &#123; succ = null; pred = last; &#125; else &#123; // 在已有数据的中间插入 // 如果 当前的site 为10，当时我们传递的 index为15, 则会在是最后的一个元素也就是10 后面追加 succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); // 第一次创建时, 那么第一个节点就是 first节点 if (pred == null) first = newNode; else // 将 pred的下一个节点向下新创建的节点 pred.next = newNode; // 将 pred 改为当前节点，方便下一个元素操作 pred = newNode; &#125; // 直接在已有的数据后面追加元素的话, succ是为空的, 所以将最后节点设置为新增元素的最后一个元素的节点 if (succ == null) &#123; last = pred; &#125; else &#123; // 在中间新增的话, 经过上面的处理后, 已有的数据前部分已经和新增的数据连接在已经了, 下面的处理 已有数据的后面部分，将其拼接到新的链表的后面 // pred 当前为新的链表的最后节点了, 将他指向了原有数据后半部分的第一个节点 pred.next = succ; // 原有数据后半部分的第一个节点的前一个节点 设置为新的链表的最后节点了 succ.prev = pred; &#125; // 当前的长度 size += numNew; // 修改次数加1 modCount++; return true; &#125; /** * 操作的位置是否合法 */ private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 指定的位置 是否合法 */ private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size; &#125; /** * 找到需要的位置的当前的节点 */ Node&lt;E&gt; node(int index) &#123; // 此次做了一个小优化， 当要查找的位置 小于 现有数据的一半, 从前往后找, 大于的话, 从后面开始找 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; // 如果 当前的site 为10， 当时我们传递的 index为15, 则会在是最后的一个元素后面追加 for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125;&#125;从代码可知LinkedList是基于双向链表实现了LinkedList的数据 是通过 first(节点) 和 last(节点) 和 size 三个共同维护的LinkedList内部的数据通过泛型，维持了自己的类型, 没有转为 Object。LinkedList的无参构造函数，没有执行任何操作LinkedList的添加元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 添加元素，默认添加到最后 */public boolean add(E e) &#123; linkLast(e); return true;&#125;/** * 指定位置添加元素 */public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;/** * 添加元素到头部 */public void addFirst(E e) &#123; linkFirst(e);&#125;/** * 添加元素到尾部 */public void addLast(E e) &#123; linkLast(e);&#125;/** 这个方法在 创建时讲过了 */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;&#125;/** * 添加元素到最后面 */void linkLast(E e) &#123; // 声明一个变量 临时存储 当前的最后一个元素 final Node&lt;E&gt; l = last; // 将插入的元素封装为node, 并且将他的前街道设置为 last final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 将LinkedList的最后一个元素设置为新的元素 last = newNode; // 如果一开始的最后一个元素就是为null, 也就是没有第一次往LinkedList放入元素，将first元素设置为当前元素 if (l == null) first = newNode; else // 否则 设置一开始的最后一个元素的下一个节点为当前的新节点 l.next = newNode; size++; modCount++;&#125;/** * 添加元素到最前面(大体和linkLast类似) */private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++;&#125;/** * 将某个元素存到某个节点的前面 */void linkBefore(E e, Node&lt;E&gt; succ) &#123; // pred 为指定节点的前置节点 final Node&lt;E&gt; pred = succ.prev; // 将元素封装为Node, 同时设置一个节点的前置节点为 需要插入节点的前置节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // 将被插入的节点的前置节点设置为新节点 succ.prev = newNode; // 如果插入的节点刚好为第一个节点，那么将新的节点更新为前置节点 if (pred == null) first = newNode; else // 设置前置节点的后一个劲节点为新的节点 pred.next = newNode; size++; modCount++;&#125;从代码中, 我们可以指定往LinkedList中添加数据的过程不需要确定LInkedList的容量, 也就不需要扩容等操作, 数据量也没有上限每次新增时, 只需要把涉及到的节点的前置节点, 后置修改了就行了指定位置的插入, 也就比插入到最后的情况, 多修改了一个后置节点的指向LinkedList的删除元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 不指定参数, 默认删除第一个 */public E remove() &#123; return removeFirst();&#125;/** * 移除 第一个, 后面还有 removeLast，类似的不做解释了 */public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;/** * 指定位置的异常 */public E remove(int index) &#123; // 检测移除的位置是否正确 checkElementIndex(index); return unlink(node(index));&#125;/** * 删除指定 */public boolean remove(Object o) &#123; // 通过遍历所有节点，找到需要删除的节点, 然后调用 unlink() 进行删除，这里就不做解释了&#125;/** * 移除元素是第一个元素 */private E unlinkFirst(Node&lt;E&gt; f) &#123; final E element = f.item; // 找到第一个元素的下一个元素 final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // 将第一个元素设置为 next first = next; // 如果原本第一个元素就是没有后续元素时，将最后的元素设置为null if (next == null) last = null; else // 将 新的第一个元素的前置节点设置为null next.prev = null; size--; modCount++; return element;&#125;/** * 指定位置的移除 */E unlink(Node&lt;E&gt; x) &#123; final E element = x.item; // 得到将要移除的元素的后置节点 final Node&lt;E&gt; next = x.next; // 得到将要移除的元素的前置节点 final Node&lt;E&gt; prev = x.prev; // 如果前置节点为空, 说明移除的为头节点, 重新设置头节点 if (prev == null) &#123; first = next; &#125; else &#123; // 将前置节点的下一个节点设置为后置节点 prev.next = next; x.prev = null; &#125; // 如果后置节点为空, 说明移除的为为节点, 重新设置为节点 if (next == null) &#123; last = prev; &#125; else &#123; // 将后置节点的前置节点设置为前置节点 next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125;从代码中, 我们可以从LinkedList中删除数据的过程找到需要删除的节点找到节点的前置节点和后置节点修改前置节点的后一个节点为后置节点， 把后置节点的前一个节点设置为前置节点LinkedList补充LinkedList 实现了 Serializable 接口, 但是他的节点都是设置为 transient？LinkedList重写了 序列化方法 writeObject 和 发序列化方法 readObject, 在序列化中, 重新通过遍历所有节点，把所有节点数据写入到 ObjectOutputStream 。LinkedList 也是继承至 List, 也有 modCount 的操作, 也就是 LinkedList 也是支持 fail-fast机制LinkedList不是一个线程安全的集合？LinkedList是线程不安全的, 如果需要保证线程的安全性, 可以考虑使用 Collections.synchronizedList(Lise l) 函数返回一个线程安全的LinkedList类不要用 for 遍历 LinkedList123456789101112131415161718192021222324252627282930List&lt;String&gt; list2 = new LinkedList&lt;&gt;();list.add(\"1\");list.add(\"2\");list.add(\"3\");for (int i = 0; i &lt; list2.size(); i++) &#123; String item = list2.get(i); System.out.println(item);&#125;// LinkedList的源码public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123; if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125;如上: 我们通过 for 遍历 LinkedList，我们通过 get(1)时，就是我们需要 first -&gt; node1, 循环到 get(2)时, 又从 first -&gt; node1 -&gt; node2 找, 所以每次get() 都是从第一个节点一直往下找到, 需要的节点为止。 所以遍历 LinkedList可以使用 foreach（foreach循环的原理就是迭代器) 或者 迭代器LinkedList h还有其他作用吗LinkedList 实现了 Deque 接口, 所以 LinkedList 可以作为双端队列, 同时 LinkedList 的双向链表的特点，还可以作为 Stack 使用, 但是 LinkedList 的这2个功能，如果没有什么特殊的要求的话，都可以使用 ArrayDeque 替代。","path":"2019/08/17/LinkedList/","date":"08-17","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://lcn29.github.io/tags/Java/"}]},{"title":"ArrayList","text":"ArrayList数组了解 ArrayList 之前, 我们需要先了解一下数组的特点数组的内存是连续的，不存在相邻元素之间还隔着其他内存数组内存储的数据类型都是一样的数组具备了查询快，增删慢的特点ArrayList结构图:ArrayList的创建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ArrayList &#123; /** 数据存放的地方 */ transient Object[] elementData; /** 不指定容量, 创建对象用到 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** 创建容量为0的对象时用到 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 不指定容量创建 */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 指定容量创建 */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125; /** * 通过已用的集合对象进行创建 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // ArrayList c.toArray might (incorrectly) not return Object[] (see 6260652) // 此处做一个容错处理： c.toArray() 不一定会返回 Object[] 对象 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 用一个空的数组进行替代 this.elementData = EMPTY_ELEMENTDATA; &#125; &#125;&#125;从代码可知ArrayList是基于数组实现的, 所以具备了数组的所有特点数据会转为了Object, 同时存放在elementData这个对象中,如果在创建是如果不指定容量, 则会把存放数据的对象指向一个空的数组, 指定了参数的, 就创建对应容量的数组Collection.toArray()的解释, 看一下这个ArrayList的添加元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** 默认创建时的容量 */private static final int DEFAULT_CAPACITY = 10;/** ArrayList的最大容量 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** 当前数组中真实数据数量 */private int size;/** * 添加元素, 默认追加在最后面 */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); elementData[size++] = e; return true;&#125;/** * 指定位置添加元素 */public void add(int index, E element) &#123; // 判断一下 index 是否在已有的数据里面 rangeCheckForAdd(index); // 走一遍判断扩容 ensureCapacityInternal(size + 1); // 新建一个数组 数组的内容和当前的数据一样，把index后面的数据都往后退一位, 然后index位置变为null System.arraycopy(elementData, index, elementData, index + 1, size - index); // 设置 index 的元素为要插入的数据 elementData[index] = element; size++;&#125;/** * 走一遍判断当前需要的容量 */private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125; /** * 计算当前需要的最小容量 (当容量的为0时，初始为10) */private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;/** * 判断是否需要扩大容量 */private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * 扩大elementData的容量 */private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; // oldCapacity &gt;&gt; 1 相当于 oldCapacity/2的一次方 也就是 oldCapacity * 0.5 // 也就是 数组的扩容 = 原来的容量 * 1.5 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 再此扩容到 Integer.MAX_VALUE if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // Arrays.copyOf 内部时调用 System.arraycopy() 方法进行扩容的 elementData = Arrays.copyOf(elementData, newCapacity);&#125;/** * 当需要的容量超过了MAX_ARRAY_SIZE, 扩大到 Integer.MAX_VALUE */private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125;从代码中, 我们可以指定往ArrayList中添加数据的过程先计算一下当前实际需要的容量 site + 1判断一下存储数据的 elementData是否为空，为空的话，说明在初始ArrayList时，没有指定容量，默认设置当前需要的容量为10需要的容量大于当前存储数据的elementData的长度, 进行扩容。 没有的话，直接存到 elementData中扩容时计算一下当前应该扩容的容量 = 当前的容量 * 1.5 (oldCapacity + (oldCapacity &gt;&gt; 1))如果计算出来的容量还小于当前需要的容量, 则当前扩容的容量 = 需要的容量当前扩容的容量大于了Integer.MAX_VALUE - 8 (MAX_ARRAY_SIZE), 则继续扩大到 当前容量 = Integer.MAX_VALUE调用 Arrays.copyOf方法(内部通过System.arraycopy调用原始方法)进行扩容从流程我们可以指定ArrayList添加元素时, 都会去判断一下当前的容量是否足够ArrayList没有指定初始容量时, 默认为10ArrayList的存储上限为 Integer.MAX_VALUE数组每次扩容都需要通过System.arraycopy，创建新的数组对象，然后拷贝已有的数据过去，这是一个很耗时的操作，所以如果初始时知道数据的大小，指定ArrayList的大小指定位置的插入每次都会导致数组指定位置后面的数据往后移动一位ArrayList的删除元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public E remove(int index) &#123; // 判断 index是否合法 rangeCheck(index); modCount++; // 取到需要删除的元素 E oldValue = elementData(index); // 删除的元素所在的位置后面还有多少个元素 int numMoved = size - index - 1; if (numMoved &gt; 0) // 将 elementData index+1 开始到 numMoved个元素依次放到elementData的index处的后面 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 设置 site - 1 处的元素为空 elementData[--size] = null;&#125;/** * 指定对象的删除 */public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) // 调用Object的 equals比较2个对象是否为同一个 if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;/** * 通过索引找到对应的元素 */E elementData(int index) &#123; return (E) elementData[index];&#125;/** * 删除元素和 remove(int) 类型 */private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; &#125;从代码中, 我们可以从ArrayList中删除数据的过程找到需要删除的元素的索引 index然后把索引index后面的元素拼接到index后面ArrayList的查询元素123456789101112131415public E get(int index) &#123; // 检测 index 是否符合条件 rangeCheck(index); // 通过索引获取元素 return elementData(index);&#125;private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;E elementData(int index) &#123; return (E) elementData[index];&#125;ArrayList的获取元素, 就不要讲了吧，通过索引index直接从数组[index]获取ArrayList补充ArrayList 实现了 Serializable 接口, 那么他是支持序列化的, 但是他的数据是存放在 elementData 内, elementData却被 transient(对象序列化时忽略) 修饰了？我们知道 elementData 本质是一个数组，使用数组是我们需要先定义长度, 所以可能存在就是我们的数据只要3个,但是 elementData 的长度为10, 7个数据是没有的, 在序列化时, 将这几个没有的数据序列过去, 浪费了空间和浪费时间, 所以 ArrayList将 elementData设置为不用序列化的, 然后自身重写了序列化方法 writeObject 和 反序列化方法 readObject, 只把 elementData 内有效的数据序列化过去在ArrayList的 add, remove, clear 方法的调用, 可以看到 有个这行代码 modCount++ modCount的作用？这个变量是继承与父类 AbstractList 的, 这个变量记录的是：当前 ArrayList 的修改次数, 作用：用于支持 fail-fast机制(在遍历中, 发现数据被修改过了, 直接抛出异常)ArrayList 内部自己实现了一个 Iterator (代码有省略), 通过 ArrayList.iterator() 获取到的就是这个实现类123456789101112131415private class Itr implements Iterator&lt;E&gt; &#123; int expectedModCount = modCount; public E next() &#123; checkForComodification(); ... &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125;从代码我们可以知道Iterator 内部维护了一个 expectedModCount 他的值就是当前ArrayList内部数据修改过几次了每次遍历时, 都会判断 expectedModCount 的值是否等于 当前 modCount, 不等于直接抛异常, 不进行后续操作了上面的场景很大概率出现在多线程上, 一个线程在遍历， 另一个线程对ArrayList进行了修改, modCount + 1 了, 从而使得 modCount != expectedModCount, 遍历的线程立即抛出异常modCount 在 AbstractList 只是被修饰为 transient的, 没有用 volatile 修饰, 也就是存在一个线程修改了数据 但是 modCount 没有及时写到内存中，遍历线程还是能够继续执行。 所以fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。ArrayList不是一个线程安全的集合？ArrayList是线程不安全的, 如果需要保证线程的安全性, 可以考虑使用 CopyOWriteArrayList 或者使用 Collections.synchronizedList(Lise l) 函数返回一个线程安全的ArrayList类ArrayList 实现了 RandomAccess 接口有什么用？首先 RandomAccess 的定义12public interface RandomAccess &#123;&#125;从定义可以看到 RandomAccess 接口, 没有任何的东西需要我们实现, 他只做一种标示作用, 实现这个接口的类, 表示自身是支持 “随机访问”(如果有10个元素, 我们需要访问第5个, 就能直接跳到第5个进行访问, 忽略掉前面的4个元素, 还有一个顺序访问, 无论要访问第几个元素, 都需要从第一个元素开始, 一直往下找, 直到找到了需要的位置为止) 策略的(官网还特意说明了, 如果是实现了这个接口的 List, 使用for循环的方式获取数据会优于用迭代器获取数据)。1234567891011121314151617public class Collections &#123; /** * 二分查找 */ public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123; // list 支持 随机访问 或者当前的数据量 小于 5000 if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD) // 可以到源码里面看一下这个方法， 内部是通过 white 进行遍历的 return Collections.indexedBinarySearch(list, key); else // 这个 是使用 迭代器遍历的 return Collections.iteratorBinarySearch(list, key); &#125;&#125;","path":"2019/08/13/ArrayList/","date":"08-13","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://lcn29.github.io/tags/Java/"}]},{"title":"Collection.toArray的理解","text":"Collection.toArray方法的理解在查看 ArrayList 的源码的时候，发现了下面的一句话 c.toArray might (incorrectly) not return Object[] (see 6260652)1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125;详情可以查看这里, 出于好奇, 理了一下对象向上转型时1234567891011121314151617181920212223private static void test1() &#123; String str = \"123\"; Object obj = str; Object obj2 = obj; // class java.lang.String System.out.println(str.getClass()); // class java.lang.String System.out.println(obj.getClass()); // class java.lang.String System.out.println(obj2.getClass()); Integer num = 1; Number obj3 = num; // class java.lang.Integer System.out.println(num.getClass()); // class java.lang.Integer System.out.println(obj3.getClass());&#125;从上面的代码, 我们可以发现通过向上转型, 虽然对象已经是转型后的类型了，但是还是会保留了实际的类型对象为数组时12345678910private static void test2() &#123; Object[] obj = new Object[2]; obj[0] = new String(); // class java.lang.String System.out.println(obj[0].getClass()); // class [Ljava.lang.Object; System.out.println(obj.getClass());&#125;从上面的代码, 我们可以发现声明的数组是什么类型，那么他的类型就是什么。 但是放入到内部的对象, 通过转型存到了数组里面, 但是他的实际类型还是没变的。Collection.toArray()123456789101112131415private static void test3() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"123\"); Object[] objArray = list.toArray(); // class [Ljava.lang.Object; System.out.println(objArray.getClass()); List&lt;String&gt; list2 = Arrays.asList(\"123\"); Object[] objArray2 = list2.toArray(); // class [Ljava.lang.String; System.out.println(objArray2.getClass());&#125;ArrayList.toArray()返回的是 Object[], 同时实际类型也是Object[]从官方的说法中我们可以知道, 正常情况下 Collection.toArray()和Collection.toArray(new Object[0])的返回类型应该是一样的。但是Arrays.toArray()并不符合这一条件。 ArrayList 在创建时就用一个 Object 数组存放所有的对象, 传递到 Arrays.copyOf(T[] original, int newLength) 时 T为Object, 所以转换后的对象为Object。Arrays.toArray() 返回的是 T[]Arrays内部自己实现了一个 ArrayList 类123456789101112131415private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; private final E[] a; /** 通过泛型创建了 数组 E[] 如果传递过来的是 String, 那么此时 a的类型为 String[] */ public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; /** 通过clone() 返回的是原本的类型 也就是此时 E[], 同时向上转型为Object[], 但是次数虽然类型是Object, 但是他的实际类型为 E[] */ public Object[] toArray() &#123; return a.clone(); &#125;&#125;也就是Arrays.toArray() 返回的时创建时指定的泛型类型。回到ArrayList的创建方法123// 通过这种方式创建ArrayList时, elementData的类型应该是 Stringnew ArrayList(Arrays.asList(\"12323\"));","path":"2019/08/12/Collection-toArray的理解/","date":"08-12","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://lcn29.github.io/tags/Java/"}]},{"title":"Java容器(集合)类","text":"Java容器(集合)类java的集合框架是我们平时使用频率挺高的代码, 基本涉及到数据的临时存储, 都能见到他们的身影。 但是在庞大的集合类中,找到一个最适合自己需求的实现类，则需要你对Java的集合框架有一定的了解。 本文将从全局出发，整理一下java的集合框架。分类整个Java集合框架的关系图如下(本图为基础版):从图中我们可以看出, Java的集合框架大体分成2派: Collection 和 MapCollection主要有3个成员List 存储在内部的数据是有序的, 同时可重复Set 不能有重复元素Queue 队列,可以保证数据的先进先出Map 则比较简单, 是一个key-value模式的存储结构，要求key不能重复，通过key可以获取到唯一的value。具体介绍List1 有序(元素存入集合的顺序和取出的顺序一致), 元素都有索引, 同时支持重复元素。2 除了具有Collection接口必备的iterator()方法外, List还提供一个listIterator()方法, 返回一个ListIterator接口。 Iterator的遍历都是从头开始一直往后遍历的，但是listIterator可以指定从哪个位置开始遍历, 同时支持往前遍历，同时增加元素, 修改元素优点：操作读取操作效率高，基于数组实现的，可以为null值，可以允许重复元素，有序，异步。缺点：由于它是由动态数组实现的，不适合频繁的对元素的插入和删除操作，因为每次插入和删除都需要移动数组中的元素。ArrayList, 详情LinkedList, 详情Vector 可以看成是一个线程安全的ArrayList, 因为他的内部大部分的方法都是通过 synchronized 进行修饰的, 和 ArrayList的区别是, 支持设置每次扩容的容量(ArrayList 默认是当前的0.5倍), 如果没有设置, Vector 默认是当前的1倍, Vector不被推荐使用了Stack 基础了Vector, 同时提供了符合栈特点的5个方法： push, pop, peek, search, empty。 研究Stack 本质就是在研究 Vetor, 所以这里就不进行讲解了。 而且 Stack 类官方已经不在建议使用了(Stack的实现有许多不规范的地方), 现在官方推荐使用 java.util.Deque。Set1 无序(存入和取出顺序有可能不一致), 不可以存储重复元素2 当存入的元素重复了, 后面的会替换已有的HashSet 详情TreeSet 详情Queue1 Queue用于模拟队列这种数据结构，实现’FIFO’等数据结构2 队列常作被当作一个可靠的将对象从程序的某个区域传输到另一个区域的途径3 队列不允许随机访问队列中的元素4 使用 Queue 实现通常不允许插入 null 元素, 因为 null 也用作 poll 方法的一个特殊返回值，表明队列不包含元素了。5 在 Java 中 和 Queue 直接关联的类有 BlockingQueue(还是一个接口, 只是基础了Queue的方法), Deque(还是一个接口, 为了规范为双向队列, 还添加了一下自身的方法), AbstractQueue(抽象类, 封装了一层)ArrayDeque 详情ArrayBlockingQueue 详情LinkedBlockingQueue 详情Map1 Map主要用于存储健值对, 根据键得到值, 因此不允许键重复, 但允许值重复2 是一个双列集合，有两个泛型key和value，使用的时候key和value的数据类型可以相同, 也可以不同HashMap 详情TreeMap 详情Hashtable 详情LinkedHashMap 详情Properties 详情使用情景List: 数据可重复, 同时有序ArrayList1) 基于数组实现的, 同时支持动态扩容2) 随机访问效率高，随机插入、随机删除效率低3) 线程不安全4) 允许放入null, 同时支持多个nullLinkedList1) 基于双向链表实现2) 随机访问效率低，但随机插入、随机删除效率高3) 线程不安全4) 允许放入null, 同时支持多个nullVector1) 基于数组实现的, 同时支持动态扩容2) 随机访问效率高，随机插入、随机删除效率低3) 线程安全4) 为了线程安全, 大部分的方法都通过 synchronized 进行修饰, 所以在效率上比ArrayList慢一些5) 允许放入null, 同时支持多个null6) 不推荐使用Vector, 大部分都加锁，导致了效率低, 而这个加锁很多时候都是你不需要的Stack1）继承于Vector, 具备了Vector的所有特性2) 同样的不推荐使用Stack, 如果需要使用栈的话，官方推荐的是ArrayDequeSet: 数据唯一, 数据无序HashSet1) 基于HashMap实现的, 也就是 数组 + 链表 + 红黑树 实现的。2）我们放入的内容, 存在了内部HashMap 的key, value 统一为 Object3) 线程不安全4）允许存入null, 但是只支持1个, 默认后者覆盖前者TreeSet1) 基于TreeMap实现的, 也就是红黑树2) TreeMap 存入的数据是有序的, 默认按照存入的值的hashCode的大小进行排序。 也可以通过实现Comparator接口, 自定义排序规则。3) 线程不安全4）不允许存nullQueue: 数据可重复, 同时有序, 但是存入和取出的顺序是相反的ArrayDeque1) 基于数组实现的双端队列2）随机访问效率高，随机插入、随机删除效率低3）线程不安全4）不允许存入null5) 不仅可以当做双端队列使用，还可以用于栈ArrayBlockingQueue1) 基于数组实现的阻塞队列, 不支持扩容2）线程安全的3）不允许存入nullLinkedBlockingQueue1）基于双向链表实现的2) 随机访问效率低，但随机插入、随机删除效率高3) 线程安全4）不允许存入nullMap: 数据需要有key-value的映射关系HashMap1）基于 数组 + 链表 + 红黑树 实现的2）存入的数据是无序的,3) 线程不安全4) 允许存入null, 但是只支持1个, 默认后者覆盖前者TreeMap1） 基于 红黑树 实现的2） 存入的数据是有序的, 默认按照存入的值的hashCode的大小进行排序。 也可以通过实现Comparator接口, 自定义排序规则。3） 线程不安全4） key不允许存入null, value 可以Hashtable1) 基于数组 + 链表实现的2）线程安全的3） key 不能为 null, value 也不能为 nullLinkedHashMap1）基于数组 + 双向链表 实现的2）线程非安全的3）key,value 都能为nullProperties1) 基于Hashtable 实现的，具有Hashtable的特点参考：集合类–最详细的面试宝典–看这篇就够用了(java 1.8)从 java.util.Stack 的原理说它为什么不被官方所推荐使用！","path":"2019/08/11/Java容器(集合)类/","date":"08-11","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://lcn29.github.io/tags/Java/"}]},{"title":"快速搭建一个自己的博客","text":"快速搭建一个自己的博客做一个自己的博客网站，基本可以从很多方面入手。从购买服务器到自己编写页面，从dns到页面优化。投入的越多,理所当然的你的网站体验就越好等。但是考虑到时间,价钱等原因，我们可以站在前人的基础上，选择最合适方式搭建自己的网站, 达到快速的搭建。技术选择GitHub + Hexo + Markdown (推荐)GitHub + Jekyll + Markdown自选服务器 + Wordpress + 插件…从免费的角度出发的话,很多人都会选择前2种吧。 而hexo是需要node环境,jekeyll需要ruby，同时hexo有现成的中文文档，所以在搭建本站是采用了Hexo,环境搭建简单的同时还有中文文档。那么开始吧,我们的博客搭建之路环境搭建1.因为用到了Github，所以需要你本地有git的环境window 可以到Git的官网下载一个GitBash，一路默认配置安装就行了。node环境安装到node的官网下载一个node，双击安装就行了。2.安装hexo打开你的cmd,执行一下1234npm install -g hexo-cli# 安装完,执行下面的命令, 可以打印出hexo-cli 的版本号,就是安装完成了hexo -v3.初始你的博客工作空间12# 新版本的hexo,在你初始的过程中,会把你项目的依赖都下来了, 也就是npm install 可以不应执行了hexo init 你的工作空间的名字4.启动你的项目12345678# 进入到你的工作空间cd /你的工作空间的名字# 打包，生成网站的文件hexo g # 启动项目hexo s这时打开你的浏览器,访问 http://localhost:4000就能看到你的网站了,如果想要停止的话, 在你的命令窗口输入ctrl+C就行了,自此你的环境就搭建成功了。如果你有将东西备份在GitHub的习惯的话，或者利用Github来做版本管理等,这时候可以把你的项目放到Github上了,步骤可以参考这里主题更换hexo初始的主题是不是有点丑呢?这时候，如果你是一个前端大佬，想要从0 开始，自定义想要的页面样子的话，可以参考官网的文档进行开发了. 如果你和我一样，对自己的审美,适配等原因而无奈的话，我们可以套用别人分享的主题。1.主题寻找首先进入hexo主题,你可以看到有很多别人分享的主题,从中选择一款你喜欢的, 本站使用的主题是这个：gal, 感谢作者的分享。说明一下，网上找的的资料，大部分的人都是以Next为例子, 文档挺全的,同时next主题也有很多人进行2次开发,样子也都挺好看的，所以如果你没有什么要求，可以尝试使用next, 后面的配置,改造有很多巨人肩膀可以给你依靠。2.导入主题找到了自己想要的主题后, 可以点击一下主题的标题，正常情况下是可以进入到作者分享的主题的github仓库。仓库的克隆地址。打开你本地项目的目录, 进入到你的themes目录,然后把刚刚的主题仓库克隆下来,把文件夹的名字复制下来回到你项目的根目录, 打开_config.yml, 有的主题在他们仓库的readme,有教你们如何配置,很多都是会把他们仓库名和主题名弄混淆,比如: hexo-theme-A-RSnippet ,文档说的配置是a-rsnippet,之所以能起作用,是他们在克隆仓库时,指定了本地的文件夹名,但是这一步很多文档是没有说的，所以很容易出现你的themes下的主题是hexo-theme-A-RSnippet, 但是你的配置是a-rsnippet，所以主题不起作用.12# 把theme修改为你的第二步复制下来的文件夹名, theme: 文件夹名(themes下一定要有和它对应的名字一模一样的主题存在)安装你想要的主题的配置文档进行其他相对应的配置。比如我使用的gal主题,需要先安装hexo-renderer-sass和hexo-renderer-scss, 才能将主题里面的scss文件编译成css文件启动项目, 这时你的的主题已经起作用了(下面的就是启动命令,后续的重启服务基本都是需要走一遍这个流程)123456# clean 清除上一次生成的文件 hexo clean # 重新生成新的文件hexo g # 启动你的服务hexo s这时,如果你想把可以代码提交到Github时,会报错You&#39;ve added another git repository inside your current repository. 大概的意思是你仓库里面有另一个仓库(你的主题仓库)。解决：进入到themes/你下载的主题/里面, 删除里面的.git文件，在回到你的项目的跟目录 git rm --cached -f themes/你下载的主题/,后面你就能提交了定制化你的博客这个基本可以通过查看对应主题的文档进行改造，比如添加归档,404页面等,根据自己的需要和对应主题的文档进行修改就行了。新建你的文章开始你的书写博客之路了1hexo new 文章的名字这时在 你的项目的根目录/source/_posts 下面有一个 你命名的文章的名字.md的文件。打开,你就可以通过markdown写下你的内容了(注头部的内容不能删除), 重新走一遍从重启服务, 这是你就能看到你写的文章了。发布你的博客利用Github Pages功能,部署到服务器, 方便别人可查看, 不了解GitHub Pages的可以先看一下这里(1) 先建立一个仓库名为{你的GitHub的用户名}.github.io的仓库,然后把它克隆到你本地,(2) 把博客项目里的public目录内的所有的文件复制到刚克隆下来的仓库里,然后提交到GitHub上(3) 这是通过浏览器访问https://{你的GitHub的用户名}.github.io就能访问到你的网站了到此你网站就算是完成了,但是这是最简单的一个静态网站，只具备了看的功能，我们来为我们的网站增加功能吧自动发布代码到你仓库每次你修改了文章等,如果都要重复上面的步骤(1)(2),是一个麻烦的过程,而Hexo为我们提供了一个插件,用于省略发布的过程(Hexo还提供了很多插件，有兴趣的可以到官网了解一下)(1)配置你本地能够免密(SSH方式)提交代码到Github, 配置的过程可以查看这里(2)安装自动发布插件 npm install hexo-deployer-git --save(3)在根目录的_config.xml文件添加1234deploy: type: git repo: git: 你GitHub Pages仓库的地址,注意此次需要为ssh的地址,如果是https的是不能上传的(4)后续你要把你的页面发布到对应的仓库时,只需要通过下面的命令就能发布到对应的仓库了1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy添加评论功能(1) 首先需要你的主题支持评论(现在大多数的主题都支持的,但是不排除没有的是不)(2)评论插件选取Hypercomments来必力GitmentGittalk…因为用的主题gal，用到是Gitment(为了可以自定义评论区的样式)，所以此次以Gitment作为例子(Gitment的作者已经一年多没维护这个项目了,所以可以的话，试着换另一个插件),其他的插件，根据对应的文档进行配置就行了。(3)到GitHub的这里注册一个oAuth(Gitment是利用Github的issure作为评论存储的)。地址在这里如图：里面的Homepage URL 和 Authorization callback如果你的项目是基于GitPages并且没有绑定自己的域名的话，按照上面的配置就可以了,如果你基于GitPages但是又绑定了自己的域名,则填自己的域名就行了,其他的搭建在自己的服务器的,则填自己服务器的对应的首页。注册成功后，你将会得到一个Client ID和Client Secret。(4)按照你的主题的设置,开启对应的设置,然后把client id 和 client secret 配置进你的文件就行了。如下，是gal主题的配置这样你的系统就具备了评论的前提了。(5)当你的文章开启了评论功能后，你打开页面, 登录后, 你会发现你的文章下有个要你初始评论的按钮，只有你点了初始，才能进行评论。这是因为Gitment是基于GitHub的issues功能的，如果要能发issues，需要有人先开启一个issure，所以你的初始按钮就是起到初始的功能不同主题的这个初始样式是不一样的哦,此处为gal主题的样式,也有可能你的主题是没有这个的脚本自动化评论如果你一次添加了很多文章，那么后续发布后, 你需要手动的登录你的网站，然后一个个的给他们初始化评论, 对自己不太好吧。我们可以通过脚本的形式每次给没有初始化过的文章自动初始。(1)首先你需要一个access token允许你通过api的方式操作你的仓库。Access token的申请，可以点这里, 点击右上角的Generate new token, 输入你的登录密码后，就能看到下面的 只需要把repo的勾上，点击Generate Token就行了。这时你会得到一串秘钥。保存起来,同时不要泄露了,如果其他人得到了这个秘钥，那么就可以通过api的方式操作你的仓库了。(2)安装可以生成网站生成站点图的插件(站点图：就是一个包含你网站所有的网页的文件,便于搜索引擎抓取你的网站)12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save(3)在你的项目的的配置文件里面加上123456# 网站站点图sitemap: path: sitemap/sitemap.xml # 百度站点图baidusitemap: path: sitemap/baidusitemap.xml有了这个配置那么后续你的打包，都会在public目录下面生成一个sitemap目录,目录里面有2个上面配置的文件,这2个文件都是用于搜索引擎抓取你的网站用的, 只是一个是专门给百度用，一个是通用的(4) 新建一个自己初始脚本脚本的内容在 这里。(里面的配置的Token已经失效了, Github在你把代码提交的时候，检测到里面有对应的Token，就会将你的token失效掉，所以当你的代码提交到Github时为了不让token失效，需要先把他删除了,再提交) 放到你的项目的根目录，这个脚本需要你根据自己的主题进行修改，里面最重要的是这个(5) token的管理因为GitHub不允许在脚本里面出现token，但是如果token不好保存，这个还会限制到你的异地开发。可以利用Travis管理你的仓库，同时管理你的token。因为这个东西, 我还在摸索中，就不介绍了添加统计有了统计功能能够帮你更清晰的认清你的网站的情况,而我们的网站是一个静态的网站,想要拥有统计的功能,就需要借助第三方的服务了。现在第三方的插件已知的有2种:leancloud和不蒜子。但是使用这2个需要你的主题支持(不支持的话，当然你也可以对页面进行修改的), 在我这边的使用中：leancloud用于在文章的访问量统计,不蒜子用于网站的访问量的统计。(1)不蒜子的使用：这里。使用很简单,在你的项目的根目录 themes/你的主题/layout/_partial/head.ejs/swing 引入想要的js文件,然后在 themes/你的主题/layout/_partial/footer.ejs/swing引入对应的统计标签就行了(2) leancloud: 使用leancloud需要实名认证，所以我的博客没有使用(在gal主题, 不使用leancloud,那么首页的文章的阅读量就无法获取了,受到了影响就这个,进入到每篇文章的的页面，文章的阅读量还是可以通过不蒜子实现的),但是Leancloud是Hexo推荐的统计插件,还是可以试着使用一下的。使用的话，可以参考这里添加live-2d(也就是页面左下角的小人了)(1) 安装对应的插件 npm install --save hexo-helper-live2d(2) 然后到这里可以找到部分live-2d模型的预览，挑选一个自己喜欢的，复制下名字(3) 安装对应的模型npm install --save npm install live2d-widget-model-模型的名称(4) 在你项目的根目录新建一个文件夹live2d_models,然后到node_modules文件夹中找到刚刚下载的live2d模型，将其复制到live2d_models中(5) 配置123456789101112131415161718live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-模型的名称 display: position: left/right width: 150 (live-2d 的显示宽) height: 400 (live-2d 的显示高) mobile: show: false react: opacity: 0.9点击心形效果(1)引入脚本，放到项目的根目录/themes/你下载的主题/source/js/(2)打开 项目的根目录/themes/你下载的主题/source/layout/_partial/head.ejs/swing 引入这个jsRss功能一个类似于订阅的功能,用户点击了rss,就相当于订阅了你，你后续发布了新的文章，订阅的用户就可以知道。(gal主题不支持这个,但是我这个做了一点小修改, 将其放到了个人的链接里面了)(1) 安装插件 npm install --save hexo-generator-feed(2) 配置(这时候你的RSS链接就是 域名/atom.xml)12345678# Rss配置plugins: hexo-generator-feedfeed: type: atom path: atom.xml # 0 全部, atom.xml每次生成容纳多少文章 limit: 20(3)现在你的网站已经支持Rss功能了, 但是用户的使用需要RSS阅读器,rss阅读器的选择可以看这个,我使用的是InoReader,因为是国外的,所以速度有点慢。静态文件压缩现在已知的压缩方式有2种: gulp和hexo-neat。 gulp我试过2次，都报错了, 放弃了。 这里介绍一下hexo-neat。(1)安装插件 npm install --save hexo-neat(2)配置12345678910111213141516171819neat_enable: true# 压缩htmlneat_html: enable: true exclude: # 压缩css neat_css: enable: true exclude: - '**/*.min.css'# 压缩jsneat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/clicklove.js'通过这个插件可以对html, css, js进行压缩，但是在压缩js是会报错,可以把上面压缩js的开关关掉就行了。关联域名本身没有绑定域名，所以没设置,可以参考这个设置coding,让百度收录hexo托管在github了，但是github是国外的，百度的爬虫是不能够爬取github的。如果你希望你做的博客能够在百度引擎上被收录，而且想要更快的访问，那么可以在国内的coding page做一个托管,Coding可以看做是国内版的GitHub,大体的操作和GitHub差不多。(1) 到coding注册一个个人账号，记住不是组织账号，现在coding应该被腾讯云整合之类的，所以只能通过qq,微信进行注册了。(2) 在coding建立一个 {你的coding名}.coding.me的仓库,同时开启Pages功能(3) 配置免密登录,可以使用和github一样的公钥(4) 配置一下你的_config.yml文件, 后续你发包后，内容都会在GitHub和Coding同时发布123456# 部署部分设置deploy: type: git repo: coding: git@git.dev.tencent.com:coding用户名/用户名.coding.me.git git: git@github.com:用户名/用户名.github.io.git这时你能想访问GitHub Pages 一样访问你在coding上的页面了, 格式 https://{你的coding名}.coding.me最后自此, 利用hexo搭建自己的博客的过程就玩了, 上面的流程可以根据自己的需要进行选择,同时也可以增加, 比如引入音乐功能(我的博客就增加了)等其他功能，可以根据自己的需要进行取舍。 同时如开头说的，现在你博客网站的优化是无上限的。(1)比如我们可以把我们的网站的大量图片放到图床上优化网站的加载速度，或者为了保证质量，也可以通过购买其他的服务商的对象存储 OSS做自己的图床(2)在你的网站前面，设置多一次cdn(3)自购服务器, 配合nginx,tomcat等,让网站运行在你自己的服务器上最后,祝各位搭建出自己满意的博客网站","path":"2019/08/04/快速搭建一个自己的博客/","date":"08-04","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://lcn29.github.io/tags/Hexo/"}]},{"title":"Github免密提交","text":"GitHub免密提交通过git bash提交代码到github时，如果没有设置的话，每次都需要输入用户名和密码，很麻烦对吧。但是可以通过设置省去每次提交时输入用户名和密码的过程。1. 基于Https1.进入到你的C:/Users/{你的电脑的用户名}2.查看是否有一个.gitconfig文件(1)如果有,打开文件, 查看里面的用户名和邮箱是不是你github的信息，不是,需要进行修改(2)如果没有, 依次输入 git config --global user.email &quot;你注册GitHub用的邮箱&quot; 和 git config --global user.name &quot;你GitHub的用户名&quot;, 如果正常的话，会在本地生成一个对应的.gitconfig文件, 文件里面是你刚刚输入过的用户名好邮箱3.在本地新建一个.git-credentials文件, 文件里面的内容为https:{GitHub的用户名}:{GitHub的登录密码}@github.com4.执行命令git config --global credential.helper store, 这是你的.gitconfig的内容应该是这样的5.这时你进行提交时，还是会要你输入一串用户名好密码，输入后，后续的提交都可以免密提交了2. 基于SSH同https方式的第一步同https方式的第二步查看本地有没有一个.ssh的文件夹，如果有,里面的文件有文件名为id_rsa和id_rsa.pub的请先进行处理，因为后续生成的用于登录github的密钥的名字冲突了(当然，你也可以直接使用这已有的公钥和密钥，前提是对你没有影响)输入要命令 ssh-keygen -t rsa -C 你注册GitHub用的邮箱,期间的三次询问，默认回车就行了，最后你会发现你的本地生成了一个.ssh的文件夹，里面有2个文件id_rsa和id_rsa.pub登录你的github,(1) 在首页点击你头像, 在下来的选项中点击Settings,(2) 在左侧的侧边栏，选择SSH and GPG keys,(3) 在右侧中, 选择 New SSH key(4) 打开你本地.ssh文件夹里面的id_rsa.pub,复制里面的全部内容(5) 回到Github刚刚打开的页面，在里面的title栏，输入一个可以让你知道这个公钥的作用的提示就行了，然后把你复制的内容黏贴到下面的key栏，点击Add SSH Key就行了。这样只要你后续不删除.ssh里面的内容，你就可以一直免密提交东西到github了。3. 备注因为我的系统是window的，所以上面的2种方式都是cd 到了 C:/Users/{你的电脑的用户名}, 如果是Mac,应该是/Users/username2种方式要实现免密提交的大前提还有：你的仓库是使用对应的方式克隆下来的。如果你的仓库是通过https克隆下面的，那么ssh的免密提交是不起作用的，同理,ssh克隆下来的,https的方式不起作用","path":"2019/08/04/Github免密提交/","date":"08-04","excerpt":"","tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://lcn29.github.io/tags/GitHub/"}]},{"title":"Git提交撤销","text":"Git提交撤销把自己修改后的代码提交到远程的主干,通常需要经过 本地工作目录 -&gt; 暂存区 -&gt; 本地分支 -&gt; 远程分支。 其中第一个箭头就是git add,第二个表示git commit, 第三个箭头表示git push。我们需要经过这3步才能将我们做的修改发布到远程的分支。这三步如果有哪一步提交了，但是你又想撤销了，都可以通过对应的命令进行撤销git add的撤销(1) 需要撤销全部1git reset HEAD(2) 只需要撤销某个文件1git reset HEAD 你想要撤销的文件git commit的撤销(1) 因为提交的备注错了,只需要修改备注12# 执行下面的命令,会进入到vim模式，可以执行对你的备注进行修改git commit --amend(2) 不删除工作空间改动代码, 撤销 commit, 同时撤销add123git reset HEAD^# 下面的效果和上面的一样git reset --mixed HEAD^(3) 不删除工作空间改动代码, 撤销 commit, 但是不撤销add1git reset --soft HEAD^(4) 删除工作空间改动代码(回到上次commit的样子)，撤销commit，撤销add1git reset --hard HEAD^[注]上面的HEAD^ 可以替代成HEAD~1,在 Git的1.8.5版本之后，HEAD有一个缩写形式@,既上面所有的HEAD都可以替换为@git push的撤销情景： 现在有一个文件a,第一次在a里面写入1, push成功了,第二次在a里面写入2, push也成功了,第三次在a里面写入3, push成功了,现在a的内容为’1,2,3’。通过 git reset 进行撤销(1) 如果你现在只是想撤回3的提交,那么你可以直接1234567891011# 通过 git long 查找到2的提交id, 下面的命令可以加上参数 --oneline 减少一些没有的信息git log# 查找到了，通过q退出查找q# 回滚git reset 2的commitId# 强制提交到远程分支git push origin 分支名 --force(2)如果想要撤回3,2的提交(同时撤销多个提交)123456789101112git logq# 回到 1处git reset 1的commitId# 把head重新移到最新的commitId, 这是你的内容还是1的内容, 没有这一步，后续的提交会报错git reset 远程分支最新的commitId# 提交git push[注]reset 的三个参数(hard,soft,mixed)，根据自身的需要进行选择添加通过 git revert 进行撤销(1) 如果你现在只是想撤回3的提交,那么你可以直接123456git logq# 此次的commitId为你想要撤销的Id，而不是下一个的commitIdgit revert 3处的commitIdgit push(2)如果想要撤回3,2的提交(同时撤销多个提交)1234git logqgit revert 3处的commitId 2处的commitIdgit push[注]revert运行跨commit进行回滚的，前提的是你想要回滚的commit涉及的文件，在后面都没有被修改过revert和reset的区别revert是提交一个新的commit来回滚的, commit的内容就是和已想要回滚的那个commit相反的操作reset 是直接删除指定的commit, 后续的commit记录是看不到的上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突.但是revert 并不会如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的建议：用git revert来撤销已经提交的更改，而git reset用来撤销没有提交的更改参考：git push之后回滚(撤销)代码","path":"2019/08/04/Git提交撤销/","date":"08-04","excerpt":"","tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://lcn29.github.io/tags/GitHub/"}]},{"title":"Git提交","text":"Git提交1. 代码提交平时如果使用Github，没有按照客户端的话,或者借助开发工具(eclipse, idea等自带的插件),我们都是通过Git的控制台进行操作的，如果要提交代码的话, 我们需要依次1234# 添加当前路径和路径下面的所有修改过的文件git add .git commit -m '提交的备注'git push我们可以通配置github免密提交，然后把上面的三个命令封装为一个shell脚本(也可以封装成window的cmd，可俺不会)，后续直接执行一次这个脚本,就能提交修改了1git add . &amp;&amp; git commit -m $1 &amp;&amp; git push新建一个push.sh文件，然后把上面的内容复制到文件内,然后把文件放到你的仓库的根目录,后续修改了代码，需要提交时只有打开git的bash 输入 sh push.sh &#39;提交的备注&#39;就行了缺点：每次提交都是全部内容提交，没法做出筛选(可以修改一下脚本, 增加一个参数：提交的目录文件)2. 将本地已有的代码提交到一个新的仓库如果你本地已有一部分写好的代码，现在想要用Github进行版本管理等，又不想改变本地的工作空间，那么你可以在Github上新建一个仓库，仓库名和你本地代码的工作空间的名称一样,(如，你的代码在D/code/project/Test, test下面就是你想要提交到Github的内容,那么你的仓库名就是Test)然后在你代码的根目录(也就是Test里面) 执行 git initgit remote add origin 你的仓库地址 把你本地和远程的git仓库绑定git pull 拉取远程仓库的内容git add . 把本地代码提交到git的缓存区 (如果有文件不想要提交的，提前建立好.gitignore文件进行过滤)git commit -m &#39;提交备注&#39;git push -u origin 你想要提交到的分支(master) 提交到远程仓库","path":"2019/08/04/Git提交/","date":"08-04","excerpt":"","tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://lcn29.github.io/tags/GitHub/"}]},{"title":"GitHubPages介绍","text":"GitHub Pages介绍12Websites for you and your projects.Hosted directly from your GitHub repository. Just edit, push, and your changes are live.我的理解：一个依托于Github仓库的展示你或者你的项目的静态网站。当你的网站做了修改，只有将其托送到对应的Github仓库,那么你的修改就能立即生效。2. 展示你基于GitHub Pages建立一个属于你自己的网站的步骤:(1)第一步建立一个仓库在Github上建立一个仓库，这个仓库和平时你存项目的仓库没有什么区别，唯一的要求就是仓库的名字的格式： {你的Github用户名}.github.io 这个格式是保证后续能够访问到你的仓库内容要求(2)在你的仓库里面新建一个index.html页面(index.html就是你的网站的入口)&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;title&gt;Examples&lt;/title&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"keywords\" content=\"\"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello GitHub Pages !&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;通过上面2步上面，一个展示你的网站就完成了。这是你通过浏览器访问https://{你的Github用户名}.github.io你将看到你index里面的内容了: Hello GitHub Pages。后续你只要修改index.html页面或者添加新的页面，在提交到你的仓库，那么对应的页面就会修改。所以你完全可以通过GitPage做一个你想要的网站[注] 如果你拥有一个组织，也想建立一个展示你组织的网站,方式和上面类似，只是{你的Github用户名}修改为{你的组织的名}3. 展示你项目假设你把你的一个项目托管到了github,并将其开源了。那么为了让别人能开心的使用你的开源项目，当前需要有对应的说明文档吧。这是你会?直接写在readme开一个wiki这2种方式都可以。 现在你可以多一种方式了：为你的项目建一个GitHub Pages,通过网页的形式进行介绍第一步在你的开源项目下新建一个分支 (分支名：gh-pages)在你的分支里面放入你想要展示的页面(如果你的项目的master里面原本是有内容的，切的分支里面也会有对应的内容,因为这条分支后续是不会合并内容到主干的，所以可考虑把这些内容删除,方便后续的管理)这时你就可以通过 https://{你的用户名}.github.io/{你的项目仓库名(大小写要一致)}访问到你的项目了GitHub Pages了4. 注意事项GitHub Pages 网站是在网络上公开使用的，即使他们的库是私有的。如果你敏感的数据在你的Page库中，你可能需要在发布之前删除它5. 使用限制GitHub Pages源库建议限制在1GB内发布的GitHub Pages网站体积最大不能超过1GB,(还有每个月限制100000的访问量,但是从官网来看的话，这个限制应该是没有了)GitHub Page网站带宽限制是100GbGitHub Pages页面网站每小时最多有10次构建如果你超过了这些使用配额，Github官方将不会提供给你的网站提供服务，或者你可能会受到一个有礼貌的邮件，它是来自GitHub Support的建议策略，目的是降低你的网站对GitHub服务器的影响。建议其中包括迁移到一个不同的主机服务以便更加满足你的需求。6.禁止事项GitHub的服务条款禁止的或非法的内容或活动暴力或威胁性的内容或活动过多的自动化批量活动(例如，垃圾邮件)危害github用户或github服务的活动快速致富计划,也就是赌博等活动色情内容歪曲你的身份或网站目的的内容","path":"2019/08/01/GitHubPages介绍/","date":"08-01","excerpt":"","tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://lcn29.github.io/tags/GitHub/"}]}]}