{"meta":{"title":"lcn的博客","subtitle":"学无止境","description":"好记性不如烂笔头","author":"lcn","url":"http://lcn29.github.io","root":"/"},"pages":[{"title":"404 Not Found","text":"","path":"/404.html","date":"07-12","excerpt":""},{"title":"关于我","text":"","path":"about/index.html","date":"07-13","excerpt":""},{"title":"文章分类","text":"","path":"categories/index.html","date":"07-13","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-12","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"07-13","excerpt":""}],"posts":[{"title":"ArrayDeque","text":"ArrayDequeArrayDequeArrayDeque是一个基于数组实现的双端队列(double-ended-queue)。 Deque接口除了提供操作双端队列的一系列方法之外，还提供了操作栈的方法，因此ArrayDeque也可以表示一个栈。基于数组实现队列时, 我们添加数据时, 可以直接在尾部添加了数据，但是如果我们要取数据呢，我们把第一个取出来后，后面的数据都往前移一位, 这是一个很费时的操作。 为了解决这个问题, 我们引入了2个索引, 一个指向了头, 另一个指向了数组有效数据的后一位(第一个空位), 这样我们取的时候, 头部置为空，然后头指针往后移一位。 添加时, 如果尾指针已经到了最后一位, 那么重新到数组的头部查找, 放到头部。 最后通过判断头尾指针是否一样，来决定是否要扩容。结构图:操作方法offer系列add系列方法描述offerFirst()addFirst()将指定的元素插入到队首offerLast()addLast()将指定的元素添加到队尾pollFirst()removeFirst()取出并删除队首的元素pollLast()removeLast()取出并删除队尾的元素peekFirst()getFirst()取出队首的元素，但不删除peekLast()getLast()取出队尾的元素，但不删除它们的区别是：offer系列方法在操作失败时会返回一个特殊值（根据操作的不同，为false或者null）；add系列方法在操作失败时会抛出异常。ArrayDeque的创建123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157public class ArrayDeque &#123; transient Object[] elements; // 队首元素的索引 transient int head; // 队尾的下一个索引 transient int tail; private static final int MIN_INITIAL_CAPACITY = 8; /** * 无参 */ public ArrayDeque() &#123; // 没有指定容量, 默认为2^4 16 // arrayDeque 的容量设置为都是2的n次方, 是为了方便后续的操作 elements = new Object[16]; &#125; /** * 指定容量 */ public ArrayDeque(int numElements) &#123; // 指定了大小, 会根据你传入的值, 扩大到第一个大于你传入的值的2的n次方 allocateElements(numElements); &#125; /** * 传递集合 */ public ArrayDeque(Collection&lt;? extends E&gt; c) &#123; // 根据 出入的 Collection的大小，进行扩容 allocateElements(c.size()); // 添加c到数组中 addAll(c); &#125; /** * 创建对象 */ private void allocateElements(int numElements) &#123; elements = new Object[calculateSize(numElements)]; &#125; /** * 计算容量 */ private static int calculateSize(int numElements) &#123; // MIN_INITIAL_CAPACITY = 8; // 从这里可以看出 ArrayDeque的最小容量 为8 int initialCapacity = MIN_INITIAL_CAPACITY; if (numElements &gt;= initialCapacity) &#123; initialCapacity = numElements; // &gt;&gt;&gt; 无符号 右移 =&gt; 右移后，最高位直接取0 // 经过下面的6步 可以将 initialCapacity 变成 第一个大于 numElements的2的n次方 // 要理解下面的算法，有一点认识： // 第一： 2^n 二进制的形式为: 从1到n位 都是0, 第n+1位为1 // 如 (int)256 2^8 =&gt; 00000000 00000000 00000001 00000000 // 第二： 那么 2^n - 1 就能推出 =&gt; 从1到n-1位 都是1 第n位为0, // 255 =&gt; 00000000 00000000 00000000 11111111 // 设 initialCapacity 转为2进制后, 有效的位算为x位, //既从右往左算到最后一个1的长度, 如上面的 256, x就是9, 255, x就是8 // 第一步: initialCapacity二进制 表示 =&gt; 1 + (x-1 个 0/1), // initialCapacity &gt;&gt;&gt; 1 =&gt; 01 + (x-2 个 0/1), //或(|)运算后 =&gt; 11(x-2 个 0/1) =&gt; initialCapacity的有效位的前2位都为1了 // 第二步: initialCapacity =&gt; 11(x-2 个 0/1), // initialCapacity &gt;&gt;&gt; 2 =&gt; 0011(x-4 个 0/1), |运算后 =&gt; 1111（x-4 个 0/1）=&gt; 前4位都为1了 // ... // 经过了前 5 步 initialCapacity 变成了 1(x-1 个 1) // 第6步 + 1 initialCapacity 变成了 1(x个0) 也就是变成了 2 ^ initialCapacity的有效位 也就是变成了 2^n initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; // 做一个容错, 如果 numElements很大的时候，经过位运算 会变成负的 // 可以推导出 numElements的值 &gt;= 2^30 时, 就会变为负 // 2^30 的二进制 =&gt; 01000000 00000000 00000000 00000000 (int的长度为32位) // 经过上面的 上面的前 5步 initialCapacity=&gt; 01111111 11111111 11111111 11111111 // 在经过 第 6步, initialCapacity=&gt; 10000000 00000000 00000000 00000000 =&gt; -2147483648 变成了负了 // 这时在将 initialCapacity 右移1位，转为正的 initialCapacity &gt;&gt;&gt;= 1 =&gt; 01000000 00000000 00000000 00000000 // 最终可以得出 ArrayDeque 的最大容量为 1073741824 2^31 if (initialCapacity &lt; 0) // 最大的容量 2^30个 元素 initialCapacity &gt;&gt;&gt;= 1; &#125; return initialCapacity; &#125; /* * 使用的是父类 AbstractCollection的addAll方法 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified; &#125; /** * 添加元素 默认添加到后面 */ public boolean add(E e) &#123; addLast(e); return true; &#125; /** * 将元素添加到最后面 */ public void addLast(E e) &#123; // ArrayDeque不允许放入null if (e == null) throw new NullPointerException(); // 添加到后面 elements[tail] = e; // 尾部指针往后 + 1 判断是否需要扩容 // 下面的 a &amp; (b -1) 当 b为 2^n, 同时 a &gt; 0 的情况下 a&amp;(b-1) 效果等同于 a%b(取模) // 头和尾指针一样, 容量满了， 进行扩容 if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); &#125; /** * 扩容 */ private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; // 头指针右边的数量 int r = n - p; // 扩容 变为原来的2倍 int newCapacity = n &lt;&lt; 1; if (newCapacity &lt; 0) throw new IllegalStateException(\"Sorry, deque too big\"); Object[] a = new Object[newCapacity]; // 把原本的右边的放到a的开始位置 System.arraycopy(elements, p, a, 0, r); // 把左边的放到了 a 的r的位置 System.arraycopy(elements, 0, a, r, p); elements = a; head = 0; tail = n; &#125;&#125;添加12345678910111213141516171819202122232425262728293031323334353637/** * 放到头部 */public boolean offerFirst(E e) &#123; addFirst(e); return true;&#125;/** * 放到头部 */public void addFirst(E e) &#123; if (e == null) throw new NullPointerException(); // head的取值 [0, elements.length - 1], head - 1 =&gt; [-1, elements.length - 2], // 如果 head为 -1， 二进制为 11111111 11111111 11111111 11111111 // 这样, 当 head -1 为 -1时，通过 &amp; 得到的值 就是elements.length - 1, 回到了数组的最后的一位了。 // 当 head -1 &gt;= 0, 那么就是 相当于取模, 同时 head 一定不会大于 elements.length, // 所以 结果就是 head - 1的值, 也就是让head前进一位， // 所以下面的方法, 使得 head = 0 时， head = elements.lenght head &gt;0, head = head -1; // 最终 形成了一个循环 elements[head = (head - 1) &amp; (elements.length - 1)] = e; if (head == tail) doubleCapacity();&#125;/** * 追加到后面 */public boolean offerLast(E e) &#123; // 看上面的构造方法 addLast(e); return true;&#125;删除1234567891011121314151617181920212223242526272829303132/** * 取出并删除队首的元素 */public E pollFirst() &#123; int h = head; E result = (E) elements[h]; if (result == null) return null; elements[h] = null; // 此次相当于取模 (h + 1) % elements.lenght 当 h已经是队尾了，可以回到头部 head = (h + 1) &amp; (elements.length - 1); return result;&#125;/** * 取出并删除队首元素 */public E pollLast() &#123; // 此次的原理 同 addFirst() int t = (tail - 1) &amp; (elements.length - 1); E result = (E) elements[t]; if (result == null) return null; elements[t] = null; tail = t; return result;&#125;获取123456789101112131415/** * 取出队首的元素，但不删除 */public E peekFirst() &#123; return (E) elements[head];&#125;/** * 取出队尾的元素，但不删除 */public E peekLast() &#123; // 因为默认 tail 不是指向 尾元素，而是尾元素的后一个元素, 所以需要计算一下 return (E) elements[(tail - 1) &amp; (elements.length - 1)];&#125;补充ArrayDeque 是一个线程不安全的集合ArrayDeque 不允许存放null元素ArrayDeque 不仅可以作为双端队列使用，还可以当做栈使用, 官方也是推荐的，里面还提供对应的操作 push, popArrayDeque 也是自己重写了序列化和发序列化方法ArrayDeque 当用作栈时，性能优于Stack，当用于队列时，性能优于LinkedListArrayDeque 也是支持fail-fast机制, 内部自己实现了Iterator接口, 当是他用的不是modCount, 而是自身的指针tail，每次遍历时判断当前的tail是否修改过了，是的话直接扔 ConcurrentModificationExceptionArrayDeque 内部还实现了一个 DescendingIterator 的迭代器，可以用于从尾部遍历到头部","path":"2019/08/17/ArrayDeque/","date":"08-17","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://lcn29.github.io/tags/Java/"}]},{"title":"LinkedList","text":"LinkedList链表LinkedList 是基于 双向链表实现的。单链表, 双链表, 循环链表的定义, 可以看一下这个链表内存是散乱的, 每一个元素存储本身内存地址的同时还存储下一个元素的地址链表具备了增删快, 查找慢的特点LinkedList 是基于双向链表设计的, 所以具备了链表的特点LinkedList结构图:LinkedList的创建123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143public class LinkedList&lt;E&gt; &#123; /** 当前的数据个数 */ transient int size = 0; /** Node是LinkedList的一个内部类 第一个节点 */ transient Node&lt;E&gt; first; /** 最后一个节点 */ transient Node&lt;E&gt; last; /** * LinkedList 内部类 */ private static class Node&lt;E&gt; &#123; /** 当前节点的内容 */ E item; /** 下一个节点 */ Node&lt;E&gt; next; /** 上一个节点 */ Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; public LinkedList() &#123; &#125; /** * 给定集合创建 */ public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; /** * 从指定位置, 批量添加元素 * 下面的方法可以分成这几个 * 1. 当前的数据都为null, 那次c中的第一个数据，封装成node, node的pre为空, 将LinkedList的first设置为这个node, 后面的数据依次拼在node的后面 * 2. 已有数据，新增的数据追加在已有数据的最后面, 直接拼在最后就行了 * 3，已有数据，新增数据插在已有的中间, 把已有数据安装需要插入的位置分成2部分， A, B, 把新增的数据 先拼到A的后面， 然后把B在拼到新的A的后面 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; // pred: 新增的元素的将要插入的位置的前一个节点 succ: 新增的元素的将要插入的位置的节点 // 假设 新增的元素的位置为a, 那么 pred 就是 a的前一位的节点, succ 就是a节点 Node&lt;E&gt; pred, succ; // 需要添加的元素刚好追加在已有的后面的 if (index == size) &#123; succ = null; pred = last; &#125; else &#123; // 在已有数据的中间插入 // 如果 当前的site 为10，当时我们传递的 index为15, 则会在是最后的一个元素也就是10 后面追加 succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); // 第一次创建时, 那么第一个节点就是 first节点 if (pred == null) first = newNode; else // 将 pred的下一个节点向下新创建的节点 pred.next = newNode; // 将 pred 改为当前节点，方便下一个元素操作 pred = newNode; &#125; // 直接在已有的数据后面追加元素的话, succ是为空的, 所以将最后节点设置为新增元素的最后一个元素的节点 if (succ == null) &#123; last = pred; &#125; else &#123; // 在中间新增的话, 经过上面的处理后, 已有的数据前部分已经和新增的数据连接在已经了, 下面的处理 已有数据的后面部分，将其拼接到新的链表的后面 // pred 当前为新的链表的最后节点了, 将他指向了原有数据后半部分的第一个节点 pred.next = succ; // 原有数据后半部分的第一个节点的前一个节点 设置为新的链表的最后节点了 succ.prev = pred; &#125; // 当前的长度 size += numNew; // 修改次数加1 modCount++; return true; &#125; /** * 操作的位置是否合法 */ private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 指定的位置 是否合法 */ private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size; &#125; /** * 找到需要的位置的当前的节点 */ Node&lt;E&gt; node(int index) &#123; // 此次做了一个小优化， 当要查找的位置 小于 现有数据的一半, 从前往后找, 大于的话, 从后面开始找 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; // 如果 当前的site 为10， 当时我们传递的 index为15, 则会在是最后的一个元素后面追加 for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125;&#125;从代码可知LinkedList是基于双向链表实现了LinkedList的数据 是通过 first(节点) 和 last(节点) 和 size 三个共同维护的LinkedList内部的数据通过泛型，维持了自己的类型, 没有转为 Object。LinkedList的无参构造函数，没有执行任何操作LinkedList的添加元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 添加元素，默认添加到最后 */public boolean add(E e) &#123; linkLast(e); return true;&#125;/** * 指定位置添加元素 */public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;/** * 添加元素到头部 */public void addFirst(E e) &#123; linkFirst(e);&#125;/** * 添加元素到尾部 */public void addLast(E e) &#123; linkLast(e);&#125;/** 这个方法在 创建时讲过了 */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;&#125;/** * 添加元素到最后面 */void linkLast(E e) &#123; // 声明一个变量 临时存储 当前的最后一个元素 final Node&lt;E&gt; l = last; // 将插入的元素封装为node, 并且将他的前街道设置为 last final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 将LinkedList的最后一个元素设置为新的元素 last = newNode; // 如果一开始的最后一个元素就是为null, 也就是没有第一次往LinkedList放入元素，将first元素设置为当前元素 if (l == null) first = newNode; else // 否则 设置一开始的最后一个元素的下一个节点为当前的新节点 l.next = newNode; size++; modCount++;&#125;/** * 添加元素到最前面(大体和linkLast类似) */private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++;&#125;/** * 将某个元素存到某个节点的前面 */void linkBefore(E e, Node&lt;E&gt; succ) &#123; // pred 为指定节点的前置节点 final Node&lt;E&gt; pred = succ.prev; // 将元素封装为Node, 同时设置一个节点的前置节点为 需要插入节点的前置节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // 将被插入的节点的前置节点设置为新节点 succ.prev = newNode; // 如果插入的节点刚好为第一个节点，那么将新的节点更新为前置节点 if (pred == null) first = newNode; else // 设置前置节点的后一个劲节点为新的节点 pred.next = newNode; size++; modCount++;&#125;从代码中, 我们可以指定往LinkedList中添加数据的过程不需要确定LInkedList的容量, 也就不需要扩容等操作, 数据量也没有上限每次新增时, 只需要把涉及到的节点的前置节点, 后置修改了就行了指定位置的插入, 也就比插入到最后的情况, 多修改了一个后置节点的指向LinkedList的删除元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 不指定参数, 默认删除第一个 */public E remove() &#123; return removeFirst();&#125;/** * 移除 第一个, 后面还有 removeLast，类似的不做解释了 */public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;/** * 指定位置的异常 */public E remove(int index) &#123; // 检测移除的位置是否正确 checkElementIndex(index); return unlink(node(index));&#125;/** * 删除指定 */public boolean remove(Object o) &#123; // 通过遍历所有节点，找到需要删除的节点, 然后调用 unlink() 进行删除，这里就不做解释了&#125;/** * 移除元素是第一个元素 */private E unlinkFirst(Node&lt;E&gt; f) &#123; final E element = f.item; // 找到第一个元素的下一个元素 final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // 将第一个元素设置为 next first = next; // 如果原本第一个元素就是没有后续元素时，将最后的元素设置为null if (next == null) last = null; else // 将 新的第一个元素的前置节点设置为null next.prev = null; size--; modCount++; return element;&#125;/** * 指定位置的移除 */E unlink(Node&lt;E&gt; x) &#123; final E element = x.item; // 得到将要移除的元素的后置节点 final Node&lt;E&gt; next = x.next; // 得到将要移除的元素的前置节点 final Node&lt;E&gt; prev = x.prev; // 如果前置节点为空, 说明移除的为头节点, 重新设置头节点 if (prev == null) &#123; first = next; &#125; else &#123; // 将前置节点的下一个节点设置为后置节点 prev.next = next; x.prev = null; &#125; // 如果后置节点为空, 说明移除的为为节点, 重新设置为节点 if (next == null) &#123; last = prev; &#125; else &#123; // 将后置节点的前置节点设置为前置节点 next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125;从代码中, 我们可以从LinkedList中删除数据的过程找到需要删除的节点找到节点的前置节点和后置节点修改前置节点的后一个节点为后置节点， 把后置节点的前一个节点设置为前置节点LinkedList补充LinkedList 实现了 Serializable 接口, 但是他的节点都是设置为 transient？LinkedList重写了 序列化方法 writeObject 和 发序列化方法 readObject, 在序列化中, 重新通过遍历所有节点，把所有节点数据写入到 ObjectOutputStream 。LinkedList 也是继承至 List, 也有 modCount 的操作, 也就是 LinkedList 也是支持 fail-fast机制LinkedList不是一个线程安全的集合？LinkedList是线程不安全的, 如果需要保证线程的安全性, 可以考虑使用 Collections.synchronizedList(Lise l) 函数返回一个线程安全的LinkedList类不要用 for 遍历 LinkedList123456789101112131415161718192021222324252627282930List&lt;String&gt; list2 = new LinkedList&lt;&gt;();list.add(\"1\");list.add(\"2\");list.add(\"3\");for (int i = 0; i &lt; list2.size(); i++) &#123; String item = list2.get(i); System.out.println(item);&#125;// LinkedList的源码public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123; if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125;如上: 我们通过 for 遍历 LinkedList，我们通过 get(1)时，就是我们需要 first -&gt; node1, 循环到 get(2)时, 又从 first -&gt; node1 -&gt; node2 找, 所以每次get() 都是从第一个节点一直往下找到, 需要的节点为止。 所以遍历 LinkedList可以使用 foreach（foreach循环的原理就是迭代器) 或者 迭代器LinkedList h还有其他作用吗LinkedList 实现了 Deque 接口, 所以 LinkedList 可以作为双端队列, 同时 LinkedList 的双向链表的特点，还可以作为 Stack 使用, 但是 LinkedList 的这2个功能，如果没有什么特殊的要求的话，都可以使用 ArrayDeque 替代。","path":"2019/08/17/LinkedList/","date":"08-17","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://lcn29.github.io/tags/Java/"}]},{"title":"ArrayList","text":"ArrayList数组了解 ArrayList 之前, 我们需要先了解一下数组的特点数组的内存是连续的，不存在相邻元素之间还隔着其他内存数组内存储的数据类型都是一样的数组具备了查询快，增删慢的特点ArrayList结构图:ArrayList的创建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ArrayList &#123; /** 数据存放的地方 */ transient Object[] elementData; /** 不指定容量, 创建对象用到 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** 创建容量为0的对象时用到 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 不指定容量创建 */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 指定容量创建 */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125; /** * 通过已用的集合对象进行创建 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // ArrayList c.toArray might (incorrectly) not return Object[] (see 6260652) // 此处做一个容错处理： c.toArray() 不一定会返回 Object[] 对象 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 用一个空的数组进行替代 this.elementData = EMPTY_ELEMENTDATA; &#125; &#125;&#125;从代码可知ArrayList是基于数组实现的, 所以具备了数组的所有特点数据会转为了Object, 同时存放在elementData这个对象中,如果在创建是如果不指定容量, 则会把存放数据的对象指向一个空的数组, 指定了参数的, 就创建对应容量的数组Collection.toArray()的解释, 看一下这个ArrayList的添加元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** 默认创建时的容量 */private static final int DEFAULT_CAPACITY = 10;/** ArrayList的最大容量 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** 当前数组中真实数据数量 */private int size;/** * 添加元素, 默认追加在最后面 */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); elementData[size++] = e; return true;&#125;/** * 指定位置添加元素 */public void add(int index, E element) &#123; // 判断一下 index 是否在已有的数据里面 rangeCheckForAdd(index); // 走一遍判断扩容 ensureCapacityInternal(size + 1); // 新建一个数组 数组的内容和当前的数据一样，把index后面的数据都往后退一位, 然后index位置变为null System.arraycopy(elementData, index, elementData, index + 1, size - index); // 设置 index 的元素为要插入的数据 elementData[index] = element; size++;&#125;/** * 走一遍判断当前需要的容量 */private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125; /** * 计算当前需要的最小容量 (当容量的为0时，初始为10) */private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;/** * 判断是否需要扩大容量 */private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * 扩大elementData的容量 */private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; // oldCapacity &gt;&gt; 1 相当于 oldCapacity/2的一次方 也就是 oldCapacity * 0.5 // 也就是 数组的扩容 = 原来的容量 * 1.5 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 再此扩容到 Integer.MAX_VALUE if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // Arrays.copyOf 内部时调用 System.arraycopy() 方法进行扩容的 elementData = Arrays.copyOf(elementData, newCapacity);&#125;/** * 当需要的容量超过了MAX_ARRAY_SIZE, 扩大到 Integer.MAX_VALUE */private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125;从代码中, 我们可以指定往ArrayList中添加数据的过程先计算一下当前实际需要的容量 site + 1判断一下存储数据的 elementData是否为空，为空的话，说明在初始ArrayList时，没有指定容量，默认设置当前需要的容量为10需要的容量大于当前存储数据的elementData的长度, 进行扩容。 没有的话，直接存到 elementData中扩容时计算一下当前应该扩容的容量 = 当前的容量 * 1.5 (oldCapacity + (oldCapacity &gt;&gt; 1))如果计算出来的容量还小于当前需要的容量, 则当前扩容的容量 = 需要的容量当前扩容的容量大于了Integer.MAX_VALUE - 8 (MAX_ARRAY_SIZE), 则继续扩大到 当前容量 = Integer.MAX_VALUE调用 Arrays.copyOf方法(内部通过System.arraycopy调用原始方法)进行扩容从流程我们可以指定ArrayList添加元素时, 都会去判断一下当前的容量是否足够ArrayList没有指定初始容量时, 默认为10ArrayList的存储上限为 Integer.MAX_VALUE数组每次扩容都需要通过System.arraycopy，创建新的数组对象，然后拷贝已有的数据过去，这是一个很耗时的操作，所以如果初始时知道数据的大小，指定ArrayList的大小指定位置的插入每次都会导致数组指定位置后面的数据往后移动一位ArrayList的删除元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public E remove(int index) &#123; // 判断 index是否合法 rangeCheck(index); modCount++; // 取到需要删除的元素 E oldValue = elementData(index); // 删除的元素所在的位置后面还有多少个元素 int numMoved = size - index - 1; if (numMoved &gt; 0) // 将 elementData index+1 开始到 numMoved个元素依次放到elementData的index处的后面 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 设置 site - 1 处的元素为空 elementData[--size] = null;&#125;/** * 指定对象的删除 */public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) // 调用Object的 equals比较2个对象是否为同一个 if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;/** * 通过索引找到对应的元素 */E elementData(int index) &#123; return (E) elementData[index];&#125;/** * 删除元素和 remove(int) 类型 */private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; &#125;从代码中, 我们可以从ArrayList中删除数据的过程找到需要删除的元素的索引 index然后把索引index后面的元素拼接到index后面ArrayList的查询元素123456789101112131415public E get(int index) &#123; // 检测 index 是否符合条件 rangeCheck(index); // 通过索引获取元素 return elementData(index);&#125;private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;E elementData(int index) &#123; return (E) elementData[index];&#125;ArrayList的获取元素, 就不要讲了吧，通过索引index直接从数组[index]获取ArrayList补充ArrayList 实现了 Serializable 接口, 那么他是支持序列化的, 但是他的数据是存放在 elementData 内, elementData却被 transient(对象序列化时忽略) 修饰了？我们知道 elementData 本质是一个数组，使用数组是我们需要先定义长度, 所以可能存在就是我们的数据只要3个,但是 elementData 的长度为10, 7个数据是没有的, 在序列化时, 将这几个没有的数据序列过去, 浪费了空间和浪费时间, 所以 ArrayList将 elementData设置为不用序列化的, 然后自身重写了序列化方法 writeObject 和 反序列化方法 readObject, 只把 elementData 内有效的数据序列化过去在ArrayList的 add, remove, clear 方法的调用, 可以看到 有个这行代码 modCount++ modCount的作用？这个变量是继承与父类 AbstractList 的, 这个变量记录的是：当前 ArrayList 的修改次数, 作用：用于支持 fail-fast机制(在遍历中, 发现数据被修改过了, 直接抛出异常)ArrayList 内部自己实现了一个 Iterator (代码有省略), 通过 ArrayList.iterator() 获取到的就是这个实现类123456789101112131415private class Itr implements Iterator&lt;E&gt; &#123; int expectedModCount = modCount; public E next() &#123; checkForComodification(); ... &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125;从代码我们可以知道Iterator 内部维护了一个 expectedModCount 他的值就是当前ArrayList内部数据修改过几次了每次遍历时, 都会判断 expectedModCount 的值是否等于 当前 modCount, 不等于直接抛异常, 不进行后续操作了上面的场景很大概率出现在多线程上, 一个线程在遍历， 另一个线程对ArrayList进行了修改, modCount + 1 了, 从而使得 modCount != expectedModCount, 遍历的线程立即抛出异常modCount 在 AbstractList 只是被修饰为 transient的, 没有用 volatile 修饰, 也就是存在一个线程修改了数据 但是 modCount 没有及时写到内存中，遍历线程还是能够继续执行。 所以fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。ArrayList不是一个线程安全的集合？ArrayList是线程不安全的, 如果需要保证线程的安全性, 可以考虑使用 CopyOWriteArrayList 或者使用 Collections.synchronizedList(Lise l) 函数返回一个线程安全的ArrayList类ArrayList 实现了 RandomAccess 接口有什么用？首先 RandomAccess 的定义12public interface RandomAccess &#123;&#125;从定义可以看到 RandomAccess 接口, 没有任何的东西需要我们实现, 他只做一种标示作用, 实现这个接口的类, 表示自身是支持 “随机访问”(如果有10个元素, 我们需要访问第5个, 就能直接跳到第5个进行访问, 忽略掉前面的4个元素, 还有一个顺序访问, 无论要访问第几个元素, 都需要从第一个元素开始, 一直往下找, 直到找到了需要的位置为止) 策略的(官网还特意说明了, 如果是实现了这个接口的 List, 使用for循环的方式获取数据会优于用迭代器获取数据)。1234567891011121314151617public class Collections &#123; /** * 二分查找 */ public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123; // list 支持 随机访问 或者当前的数据量 小于 5000 if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD) // 可以到源码里面看一下这个方法， 内部是通过 white 进行遍历的 return Collections.indexedBinarySearch(list, key); else // 这个 是使用 迭代器遍历的 return Collections.iteratorBinarySearch(list, key); &#125;&#125;","path":"2019/08/13/ArrayList/","date":"08-13","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://lcn29.github.io/tags/Java/"}]},{"title":"Collection.toArray的理解","text":"Collection.toArray方法的理解在查看 ArrayList 的源码的时候，发现了下面的一句话 c.toArray might (incorrectly) not return Object[] (see 6260652)1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125;详情可以查看这里, 出于好奇, 理了一下对象向上转型时1234567891011121314151617181920212223private static void test1() &#123; String str = \"123\"; Object obj = str; Object obj2 = obj; // class java.lang.String System.out.println(str.getClass()); // class java.lang.String System.out.println(obj.getClass()); // class java.lang.String System.out.println(obj2.getClass()); Integer num = 1; Number obj3 = num; // class java.lang.Integer System.out.println(num.getClass()); // class java.lang.Integer System.out.println(obj3.getClass());&#125;从上面的代码, 我们可以发现通过向上转型, 虽然对象已经是转型后的类型了，但是还是会保留了实际的类型对象为数组时12345678910private static void test2() &#123; Object[] obj = new Object[2]; obj[0] = new String(); // class java.lang.String System.out.println(obj[0].getClass()); // class [Ljava.lang.Object; System.out.println(obj.getClass());&#125;从上面的代码, 我们可以发现声明的数组是什么类型，那么他的类型就是什么。 但是放入到内部的对象, 通过转型存到了数组里面, 但是他的实际类型还是没变的。Collection.toArray()123456789101112131415private static void test3() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"123\"); Object[] objArray = list.toArray(); // class [Ljava.lang.Object; System.out.println(objArray.getClass()); List&lt;String&gt; list2 = Arrays.asList(\"123\"); Object[] objArray2 = list2.toArray(); // class [Ljava.lang.String; System.out.println(objArray2.getClass());&#125;ArrayList.toArray()返回的是 Object[], 同时实际类型也是Object[]从官方的说法中我们可以知道, 正常情况下 Collection.toArray()和Collection.toArray(new Object[0])的返回类型应该是一样的。但是Arrays.toArray()并不符合这一条件。 ArrayList 在创建时就用一个 Object 数组存放所有的对象, 传递到 Arrays.copyOf(T[] original, int newLength) 时 T为Object, 所以转换后的对象为Object。Arrays.toArray() 返回的是 T[]Arrays内部自己实现了一个 ArrayList 类123456789101112131415private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; private final E[] a; /** 通过泛型创建了 数组 E[] 如果传递过来的是 String, 那么此时 a的类型为 String[] */ public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; /** 通过clone() 返回的是原本的类型 也就是此时 E[], 同时向上转型为Object[], 但是次数虽然类型是Object, 但是他的实际类型为 E[] */ public Object[] toArray() &#123; return a.clone(); &#125;&#125;也就是Arrays.toArray() 返回的时创建时指定的泛型类型。回到ArrayList的创建方法123// 通过这种方式创建ArrayList时, elementData的类型应该是 Stringnew ArrayList(Arrays.asList(\"12323\"));","path":"2019/08/12/Collection-toArray的理解/","date":"08-12","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://lcn29.github.io/tags/Java/"}]},{"title":"Java容器(集合)类","text":"Java容器(集合)类java的集合框架是我们平时使用频率挺高的代码, 基本涉及到数据的临时存储, 都能见到他们的身影。 但是在庞大的集合类中,找到一个最适合自己需求的实现类，则需要你对Java的集合框架有一定的了解。 本文将从全局出发，整理一下java的集合框架。分类整个Java集合框架的关系图如下(本图为基础版):从图中我们可以看出, Java的集合框架大体分成2派: Collection 和 MapCollection主要有3个成员List 存储在内部的数据是有序的, 同时可重复Set 不能有重复元素Queue 队列,可以保证数据的先进先出Map 则比较简单, 是一个key-value模式的存储结构，要求key不能重复，通过key可以获取到唯一的value。具体介绍List1 有序(元素存入集合的顺序和取出的顺序一致), 元素都有索引, 同时支持重复元素。2 除了具有Collection接口必备的iterator()方法外, List还提供一个listIterator()方法, 返回一个ListIterator接口。 Iterator的遍历都是从头开始一直往后遍历的，但是listIterator可以指定从哪个位置开始遍历, 同时支持往前遍历，同时增加元素, 修改元素优点：操作读取操作效率高，基于数组实现的，可以为null值，可以允许重复元素，有序，异步。缺点：由于它是由动态数组实现的，不适合频繁的对元素的插入和删除操作，因为每次插入和删除都需要移动数组中的元素。ArrayList, 详情LinkedList, 详情Vector 可以看成是一个线程安全的ArrayList, 因为他的内部大部分的方法都是通过 synchronized 进行修饰的, 和 ArrayList的区别是, 支持设置每次扩容的容量(ArrayList 默认是当前的0.5倍), 如果没有设置, Vector 默认是当前的1倍, Vector不被推荐使用了Stack 基础了Vector, 同时提供了符合栈特点的5个方法： push, pop, peek, search, empty。 研究Stack 本质就是在研究 Vetor, 所以这里就不进行讲解了。 而且 Stack 类官方已经不在建议使用了(Stack的实现有许多不规范的地方), 现在官方推荐使用 java.util.Deque。Set1 无序(存入和取出顺序有可能不一致), 不可以存储重复元素2 当存入的元素重复了, 后面的会替换已有的Queue1 Queue用于模拟队列这种数据结构，实现’FIFO’等数据结构2 队列常作被当作一个可靠的将对象从程序的某个区域传输到另一个区域的途径3 队列不允许随机访问队列中的元素4 使用 Queue 实现通常不允许插入 null 元素, 因为 null 也用作 poll 方法的一个特殊返回值，表明队列不包含元素了。5 在 Java 中 和 Queue 直接关联的类有 BlockingQueue(还是一个接口, 只是基础了Queue的方法), Deque(还是一个接口, 为了规范为双向队列, 还添加了一下自身的方法), AbstractQueue(抽象类, 封装了一层)ArrayDeque 详情ArrayBlockingQueue 详情LinkedBlockingQueue 详情Map1 Map主要用于存储健值对, 根据键得到值, 因此不允许键重复, 但允许值重复参考：集合类–最详细的面试宝典–看这篇就够用了(java 1.8)从 java.util.Stack 的原理说它为什么不被官方所推荐使用！","path":"2019/08/11/Java容器(集合)类/","date":"08-11","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://lcn29.github.io/tags/Java/"}]},{"title":"快速搭建一个自己的博客","text":"快速搭建一个自己的博客做一个自己的博客网站，基本可以从很多方面入手。从购买服务器到自己编写页面，从dns到页面优化。投入的越多,理所当然的你的网站体验就越好等。但是考虑到时间,价钱等原因，我们可以站在前人的基础上，选择最合适方式搭建自己的网站, 达到快速的搭建。技术选择GitHub + Hexo + Markdown (推荐)GitHub + Jekyll + Markdown自选服务器 + Wordpress + 插件…从免费的角度出发的话,很多人都会选择前2种吧。 而hexo是需要node环境,jekeyll需要ruby，同时hexo有现成的中文文档，所以在搭建本站是采用了Hexo,环境搭建简单的同时还有中文文档。那么开始吧,我们的博客搭建之路环境搭建1.因为用到了Github，所以需要你本地有git的环境window 可以到Git的官网下载一个GitBash，一路默认配置安装就行了。node环境安装到node的官网下载一个node，双击安装就行了。2.安装hexo打开你的cmd,执行一下1234npm install -g hexo-cli# 安装完,执行下面的命令, 可以打印出hexo-cli 的版本号,就是安装完成了hexo -v3.初始你的博客工作空间12# 新版本的hexo,在你初始的过程中,会把你项目的依赖都下来了, 也就是npm install 可以不应执行了hexo init 你的工作空间的名字4.启动你的项目12345678# 进入到你的工作空间cd /你的工作空间的名字# 打包，生成网站的文件hexo g # 启动项目hexo s这时打开你的浏览器,访问 http://localhost:4000就能看到你的网站了,如果想要停止的话, 在你的命令窗口输入ctrl+C就行了,自此你的环境就搭建成功了。如果你有将东西备份在GitHub的习惯的话，或者利用Github来做版本管理等,这时候可以把你的项目放到Github上了,步骤可以参考这里主题更换hexo初始的主题是不是有点丑呢?这时候，如果你是一个前端大佬，想要从0 开始，自定义想要的页面样子的话，可以参考官网的文档进行开发了. 如果你和我一样，对自己的审美,适配等原因而无奈的话，我们可以套用别人分享的主题。1.主题寻找首先进入hexo主题,你可以看到有很多别人分享的主题,从中选择一款你喜欢的, 本站使用的主题是这个：gal, 感谢作者的分享。说明一下，网上找的的资料，大部分的人都是以Next为例子, 文档挺全的,同时next主题也有很多人进行2次开发,样子也都挺好看的，所以如果你没有什么要求，可以尝试使用next, 后面的配置,改造有很多巨人肩膀可以给你依靠。2.导入主题找到了自己想要的主题后, 可以点击一下主题的标题，正常情况下是可以进入到作者分享的主题的github仓库。仓库的克隆地址。打开你本地项目的目录, 进入到你的themes目录,然后把刚刚的主题仓库克隆下来,把文件夹的名字复制下来回到你项目的根目录, 打开_config.yml, 有的主题在他们仓库的readme,有教你们如何配置,很多都是会把他们仓库名和主题名弄混淆,比如: hexo-theme-A-RSnippet ,文档说的配置是a-rsnippet,之所以能起作用,是他们在克隆仓库时,指定了本地的文件夹名,但是这一步很多文档是没有说的，所以很容易出现你的themes下的主题是hexo-theme-A-RSnippet, 但是你的配置是a-rsnippet，所以主题不起作用.12# 把theme修改为你的第二步复制下来的文件夹名, theme: 文件夹名(themes下一定要有和它对应的名字一模一样的主题存在)安装你想要的主题的配置文档进行其他相对应的配置。比如我使用的gal主题,需要先安装hexo-renderer-sass和hexo-renderer-scss, 才能将主题里面的scss文件编译成css文件启动项目, 这时你的的主题已经起作用了(下面的就是启动命令,后续的重启服务基本都是需要走一遍这个流程)123456# clean 清除上一次生成的文件 hexo clean # 重新生成新的文件hexo g # 启动你的服务hexo s这时,如果你想把可以代码提交到Github时,会报错You&#39;ve added another git repository inside your current repository. 大概的意思是你仓库里面有另一个仓库(你的主题仓库)。解决：进入到themes/你下载的主题/里面, 删除里面的.git文件，在回到你的项目的跟目录 git rm --cached -f themes/你下载的主题/,后面你就能提交了定制化你的博客这个基本可以通过查看对应主题的文档进行改造，比如添加归档,404页面等,根据自己的需要和对应主题的文档进行修改就行了。新建你的文章开始你的书写博客之路了1hexo new 文章的名字这时在 你的项目的根目录/source/_posts 下面有一个 你命名的文章的名字.md的文件。打开,你就可以通过markdown写下你的内容了(注头部的内容不能删除), 重新走一遍从重启服务, 这是你就能看到你写的文章了。发布你的博客利用Github Pages功能,部署到服务器, 方便别人可查看, 不了解GitHub Pages的可以先看一下这里(1) 先建立一个仓库名为{你的GitHub的用户名}.github.io的仓库,然后把它克隆到你本地,(2) 把博客项目里的public目录内的所有的文件复制到刚克隆下来的仓库里,然后提交到GitHub上(3) 这是通过浏览器访问https://{你的GitHub的用户名}.github.io就能访问到你的网站了到此你网站就算是完成了,但是这是最简单的一个静态网站，只具备了看的功能，我们来为我们的网站增加功能吧自动发布代码到你仓库每次你修改了文章等,如果都要重复上面的步骤(1)(2),是一个麻烦的过程,而Hexo为我们提供了一个插件,用于省略发布的过程(Hexo还提供了很多插件，有兴趣的可以到官网了解一下)(1)配置你本地能够免密(SSH方式)提交代码到Github, 配置的过程可以查看这里(2)安装自动发布插件 npm install hexo-deployer-git --save(3)在根目录的_config.xml文件添加1234deploy: type: git repo: git: 你GitHub Pages仓库的地址,注意此次需要为ssh的地址,如果是https的是不能上传的(4)后续你要把你的页面发布到对应的仓库时,只需要通过下面的命令就能发布到对应的仓库了1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy添加评论功能(1) 首先需要你的主题支持评论(现在大多数的主题都支持的,但是不排除没有的是不)(2)评论插件选取Hypercomments来必力GitmentGittalk…因为用的主题gal，用到是Gitment(为了可以自定义评论区的样式)，所以此次以Gitment作为例子(Gitment的作者已经一年多没维护这个项目了,所以可以的话，试着换另一个插件),其他的插件，根据对应的文档进行配置就行了。(3)到GitHub的这里注册一个oAuth(Gitment是利用Github的issure作为评论存储的)。地址在这里如图：里面的Homepage URL 和 Authorization callback如果你的项目是基于GitPages并且没有绑定自己的域名的话，按照上面的配置就可以了,如果你基于GitPages但是又绑定了自己的域名,则填自己的域名就行了,其他的搭建在自己的服务器的,则填自己服务器的对应的首页。注册成功后，你将会得到一个Client ID和Client Secret。(4)按照你的主题的设置,开启对应的设置,然后把client id 和 client secret 配置进你的文件就行了。如下，是gal主题的配置这样你的系统就具备了评论的前提了。(5)当你的文章开启了评论功能后，你打开页面, 登录后, 你会发现你的文章下有个要你初始评论的按钮，只有你点了初始，才能进行评论。这是因为Gitment是基于GitHub的issues功能的，如果要能发issues，需要有人先开启一个issure，所以你的初始按钮就是起到初始的功能不同主题的这个初始样式是不一样的哦,此处为gal主题的样式,也有可能你的主题是没有这个的脚本自动化评论如果你一次添加了很多文章，那么后续发布后, 你需要手动的登录你的网站，然后一个个的给他们初始化评论, 对自己不太好吧。我们可以通过脚本的形式每次给没有初始化过的文章自动初始。(1)首先你需要一个access token允许你通过api的方式操作你的仓库。Access token的申请，可以点这里, 点击右上角的Generate new token, 输入你的登录密码后，就能看到下面的 只需要把repo的勾上，点击Generate Token就行了。这时你会得到一串秘钥。保存起来,同时不要泄露了,如果其他人得到了这个秘钥，那么就可以通过api的方式操作你的仓库了。(2)安装可以生成网站生成站点图的插件(站点图：就是一个包含你网站所有的网页的文件,便于搜索引擎抓取你的网站)12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save(3)在你的项目的的配置文件里面加上123456# 网站站点图sitemap: path: sitemap/sitemap.xml # 百度站点图baidusitemap: path: sitemap/baidusitemap.xml有了这个配置那么后续你的打包，都会在public目录下面生成一个sitemap目录,目录里面有2个上面配置的文件,这2个文件都是用于搜索引擎抓取你的网站用的, 只是一个是专门给百度用，一个是通用的(4) 新建一个自己初始脚本脚本的内容在 这里。(里面的配置的Token已经失效了, Github在你把代码提交的时候，检测到里面有对应的Token，就会将你的token失效掉，所以当你的代码提交到Github时为了不让token失效，需要先把他删除了,再提交) 放到你的项目的根目录，这个脚本需要你根据自己的主题进行修改，里面最重要的是这个(5) token的管理因为GitHub不允许在脚本里面出现token，但是如果token不好保存，这个还会限制到你的异地开发。可以利用Travis管理你的仓库，同时管理你的token。因为这个东西, 我还在摸索中，就不介绍了添加统计有了统计功能能够帮你更清晰的认清你的网站的情况,而我们的网站是一个静态的网站,想要拥有统计的功能,就需要借助第三方的服务了。现在第三方的插件已知的有2种:leancloud和不蒜子。但是使用这2个需要你的主题支持(不支持的话，当然你也可以对页面进行修改的), 在我这边的使用中：leancloud用于在文章的访问量统计,不蒜子用于网站的访问量的统计。(1)不蒜子的使用：这里。使用很简单,在你的项目的根目录 themes/你的主题/layout/_partial/head.ejs/swing 引入想要的js文件,然后在 themes/你的主题/layout/_partial/footer.ejs/swing引入对应的统计标签就行了(2) leancloud: 使用leancloud需要实名认证，所以我的博客没有使用(在gal主题, 不使用leancloud,那么首页的文章的阅读量就无法获取了,受到了影响就这个,进入到每篇文章的的页面，文章的阅读量还是可以通过不蒜子实现的),但是Leancloud是Hexo推荐的统计插件,还是可以试着使用一下的。使用的话，可以参考这里添加live-2d(也就是页面左下角的小人了)(1) 安装对应的插件 npm install --save hexo-helper-live2d(2) 然后到这里可以找到部分live-2d模型的预览，挑选一个自己喜欢的，复制下名字(3) 安装对应的模型npm install --save npm install live2d-widget-model-模型的名称(4) 在你项目的根目录新建一个文件夹live2d_models,然后到node_modules文件夹中找到刚刚下载的live2d模型，将其复制到live2d_models中(5) 配置123456789101112131415161718live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-模型的名称 display: position: left/right width: 150 (live-2d 的显示宽) height: 400 (live-2d 的显示高) mobile: show: false react: opacity: 0.9点击心形效果(1)引入脚本，放到项目的根目录/themes/你下载的主题/source/js/(2)打开 项目的根目录/themes/你下载的主题/source/layout/_partial/head.ejs/swing 引入这个jsRss功能一个类似于订阅的功能,用户点击了rss,就相当于订阅了你，你后续发布了新的文章，订阅的用户就可以知道。(gal主题不支持这个,但是我这个做了一点小修改, 将其放到了个人的链接里面了)(1) 安装插件 npm install --save hexo-generator-feed(2) 配置(这时候你的RSS链接就是 域名/atom.xml)12345678# Rss配置plugins: hexo-generator-feedfeed: type: atom path: atom.xml # 0 全部, atom.xml每次生成容纳多少文章 limit: 20(3)现在你的网站已经支持Rss功能了, 但是用户的使用需要RSS阅读器,rss阅读器的选择可以看这个,我使用的是InoReader,因为是国外的,所以速度有点慢。静态文件压缩现在已知的压缩方式有2种: gulp和hexo-neat。 gulp我试过2次，都报错了, 放弃了。 这里介绍一下hexo-neat。(1)安装插件 npm install --save hexo-neat(2)配置12345678910111213141516171819neat_enable: true# 压缩htmlneat_html: enable: true exclude: # 压缩css neat_css: enable: true exclude: - '**/*.min.css'# 压缩jsneat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/clicklove.js'通过这个插件可以对html, css, js进行压缩，但是在压缩js是会报错,可以把上面压缩js的开关关掉就行了。关联域名本身没有绑定域名，所以没设置,可以参考这个设置coding,让百度收录hexo托管在github了，但是github是国外的，百度的爬虫是不能够爬取github的。如果你希望你做的博客能够在百度引擎上被收录，而且想要更快的访问，那么可以在国内的coding page做一个托管,Coding可以看做是国内版的GitHub,大体的操作和GitHub差不多。(1) 到coding注册一个个人账号，记住不是组织账号，现在coding应该被腾讯云整合之类的，所以只能通过qq,微信进行注册了。(2) 在coding建立一个 {你的coding名}.coding.me的仓库,同时开启Pages功能(3) 配置免密登录,可以使用和github一样的公钥(4) 配置一下你的_config.yml文件, 后续你发包后，内容都会在GitHub和Coding同时发布123456# 部署部分设置deploy: type: git repo: coding: git@git.dev.tencent.com:coding用户名/用户名.coding.me.git git: git@github.com:用户名/用户名.github.io.git这时你能想访问GitHub Pages 一样访问你在coding上的页面了, 格式 https://{你的coding名}.coding.me最后自此, 利用hexo搭建自己的博客的过程就玩了, 上面的流程可以根据自己的需要进行选择,同时也可以增加, 比如引入音乐功能(我的博客就增加了)等其他功能，可以根据自己的需要进行取舍。 同时如开头说的，现在你博客网站的优化是无上限的。(1)比如我们可以把我们的网站的大量图片放到图床上优化网站的加载速度，或者为了保证质量，也可以通过购买其他的服务商的对象存储 OSS做自己的图床(2)在你的网站前面，设置多一次cdn(3)自购服务器, 配合nginx,tomcat等,让网站运行在你自己的服务器上最后,祝各位搭建出自己满意的博客网站","path":"2019/08/04/快速搭建一个自己的博客/","date":"08-04","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://lcn29.github.io/tags/Hexo/"}]},{"title":"Github免密提交","text":"GitHub免密提交通过git bash提交代码到github时，如果没有设置的话，每次都需要输入用户名和密码，很麻烦对吧。但是可以通过设置省去每次提交时输入用户名和密码的过程。1. 基于Https1.进入到你的C:/Users/{你的电脑的用户名}2.查看是否有一个.gitconfig文件(1)如果有,打开文件, 查看里面的用户名和邮箱是不是你github的信息，不是,需要进行修改(2)如果没有, 依次输入 git config --global user.email &quot;你注册GitHub用的邮箱&quot; 和 git config --global user.name &quot;你GitHub的用户名&quot;, 如果正常的话，会在本地生成一个对应的.gitconfig文件, 文件里面是你刚刚输入过的用户名好邮箱3.在本地新建一个.git-credentials文件, 文件里面的内容为https:{GitHub的用户名}:{GitHub的登录密码}@github.com4.执行命令git config --global credential.helper store, 这是你的.gitconfig的内容应该是这样的5.这时你进行提交时，还是会要你输入一串用户名好密码，输入后，后续的提交都可以免密提交了2. 基于SSH同https方式的第一步同https方式的第二步查看本地有没有一个.ssh的文件夹，如果有,里面的文件有文件名为id_rsa和id_rsa.pub的请先进行处理，因为后续生成的用于登录github的密钥的名字冲突了(当然，你也可以直接使用这已有的公钥和密钥，前提是对你没有影响)输入要命令 ssh-keygen -t rsa -C 你注册GitHub用的邮箱,期间的三次询问，默认回车就行了，最后你会发现你的本地生成了一个.ssh的文件夹，里面有2个文件id_rsa和id_rsa.pub登录你的github,(1) 在首页点击你头像, 在下来的选项中点击Settings,(2) 在左侧的侧边栏，选择SSH and GPG keys,(3) 在右侧中, 选择 New SSH key(4) 打开你本地.ssh文件夹里面的id_rsa.pub,复制里面的全部内容(5) 回到Github刚刚打开的页面，在里面的title栏，输入一个可以让你知道这个公钥的作用的提示就行了，然后把你复制的内容黏贴到下面的key栏，点击Add SSH Key就行了。这样只要你后续不删除.ssh里面的内容，你就可以一直免密提交东西到github了。3. 备注因为我的系统是window的，所以上面的2种方式都是cd 到了 C:/Users/{你的电脑的用户名}, 如果是Mac,应该是/Users/username2种方式要实现免密提交的大前提还有：你的仓库是使用对应的方式克隆下来的。如果你的仓库是通过https克隆下面的，那么ssh的免密提交是不起作用的，同理,ssh克隆下来的,https的方式不起作用","path":"2019/08/04/Github免密提交/","date":"08-04","excerpt":"","tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://lcn29.github.io/tags/GitHub/"}]},{"title":"Git提交撤销","text":"Git提交撤销把自己修改后的代码提交到远程的主干,通常需要经过 本地工作目录 -&gt; 暂存区 -&gt; 本地分支 -&gt; 远程分支。 其中第一个箭头就是git add,第二个表示git commit, 第三个箭头表示git push。我们需要经过这3步才能将我们做的修改发布到远程的分支。这三步如果有哪一步提交了，但是你又想撤销了，都可以通过对应的命令进行撤销git add的撤销(1) 需要撤销全部1git reset HEAD(2) 只需要撤销某个文件1git reset HEAD 你想要撤销的文件git commit的撤销(1) 因为提交的备注错了,只需要修改备注12# 执行下面的命令,会进入到vim模式，可以执行对你的备注进行修改git commit --amend(2) 不删除工作空间改动代码, 撤销 commit, 同时撤销add123git reset HEAD^# 下面的效果和上面的一样git reset --mixed HEAD^(3) 不删除工作空间改动代码, 撤销 commit, 但是不撤销add1git reset --soft HEAD^(4) 删除工作空间改动代码(回到上次commit的样子)，撤销commit，撤销add1git reset --hard HEAD^[注]上面的HEAD^ 可以替代成HEAD~1,在 Git的1.8.5版本之后，HEAD有一个缩写形式@,既上面所有的HEAD都可以替换为@git push的撤销情景： 现在有一个文件a,第一次在a里面写入1, push成功了,第二次在a里面写入2, push也成功了,第三次在a里面写入3, push成功了,现在a的内容为’1,2,3’。通过 git reset 进行撤销(1) 如果你现在只是想撤回3的提交,那么你可以直接1234567891011# 通过 git long 查找到2的提交id, 下面的命令可以加上参数 --oneline 减少一些没有的信息git log# 查找到了，通过q退出查找q# 回滚git reset 2的commitId# 强制提交到远程分支git push origin 分支名 --force(2)如果想要撤回3,2的提交(同时撤销多个提交)123456789101112git logq# 回到 1处git reset 1的commitId# 把head重新移到最新的commitId, 这是你的内容还是1的内容, 没有这一步，后续的提交会报错git reset 远程分支最新的commitId# 提交git push[注]reset 的三个参数(hard,soft,mixed)，根据自身的需要进行选择添加通过 git revert 进行撤销(1) 如果你现在只是想撤回3的提交,那么你可以直接123456git logq# 此次的commitId为你想要撤销的Id，而不是下一个的commitIdgit revert 3处的commitIdgit push(2)如果想要撤回3,2的提交(同时撤销多个提交)1234git logqgit revert 3处的commitId 2处的commitIdgit push[注]revert运行跨commit进行回滚的，前提的是你想要回滚的commit涉及的文件，在后面都没有被修改过revert和reset的区别revert是提交一个新的commit来回滚的, commit的内容就是和已想要回滚的那个commit相反的操作reset 是直接删除指定的commit, 后续的commit记录是看不到的上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突.但是revert 并不会如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的建议：用git revert来撤销已经提交的更改，而git reset用来撤销没有提交的更改参考：git push之后回滚(撤销)代码","path":"2019/08/04/Git提交撤销/","date":"08-04","excerpt":"","tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://lcn29.github.io/tags/GitHub/"}]},{"title":"Git提交","text":"Git提交1. 代码提交平时如果使用Github，没有按照客户端的话,或者借助开发工具(eclipse, idea等自带的插件),我们都是通过Git的控制台进行操作的，如果要提交代码的话, 我们需要依次1234# 添加当前路径和路径下面的所有修改过的文件git add .git commit -m '提交的备注'git push我们可以通配置github免密提交，然后把上面的三个命令封装为一个shell脚本(也可以封装成window的cmd，可俺不会)，后续直接执行一次这个脚本,就能提交修改了1git add . &amp;&amp; git commit -m $1 &amp;&amp; git push新建一个push.sh文件，然后把上面的内容复制到文件内,然后把文件放到你的仓库的根目录,后续修改了代码，需要提交时只有打开git的bash 输入 sh push.sh &#39;提交的备注&#39;就行了缺点：每次提交都是全部内容提交，没法做出筛选(可以修改一下脚本, 增加一个参数：提交的目录文件)2. 将本地已有的代码提交到一个新的仓库如果你本地已有一部分写好的代码，现在想要用Github进行版本管理等，又不想改变本地的工作空间，那么你可以在Github上新建一个仓库，仓库名和你本地代码的工作空间的名称一样,(如，你的代码在D/code/project/Test, test下面就是你想要提交到Github的内容,那么你的仓库名就是Test)然后在你代码的根目录(也就是Test里面) 执行 git initgit remote add origin 你的仓库地址 把你本地和远程的git仓库绑定git pull 拉取远程仓库的内容git add . 把本地代码提交到git的缓存区 (如果有文件不想要提交的，提前建立好.gitignore文件进行过滤)git commit -m &#39;提交备注&#39;git push -u origin 你想要提交到的分支(master) 提交到远程仓库","path":"2019/08/04/Git提交/","date":"08-04","excerpt":"","tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://lcn29.github.io/tags/GitHub/"}]},{"title":"GitHubPages介绍","text":"GitHub Pages介绍12Websites for you and your projects.Hosted directly from your GitHub repository. Just edit, push, and your changes are live.我的理解：一个依托于Github仓库的展示你或者你的项目的静态网站。当你的网站做了修改，只有将其托送到对应的Github仓库,那么你的修改就能立即生效。2. 展示你基于GitHub Pages建立一个属于你自己的网站的步骤:(1)第一步建立一个仓库在Github上建立一个仓库，这个仓库和平时你存项目的仓库没有什么区别，唯一的要求就是仓库的名字的格式： {你的Github用户名}.github.io 这个格式是保证后续能够访问到你的仓库内容要求(2)在你的仓库里面新建一个index.html页面(index.html就是你的网站的入口)&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;title&gt;Examples&lt;/title&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"keywords\" content=\"\"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello GitHub Pages !&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;通过上面2步上面，一个展示你的网站就完成了。这是你通过浏览器访问https://{你的Github用户名}.github.io你将看到你index里面的内容了: Hello GitHub Pages。后续你只要修改index.html页面或者添加新的页面，在提交到你的仓库，那么对应的页面就会修改。所以你完全可以通过GitPage做一个你想要的网站[注] 如果你拥有一个组织，也想建立一个展示你组织的网站,方式和上面类似，只是{你的Github用户名}修改为{你的组织的名}3. 展示你项目假设你把你的一个项目托管到了github,并将其开源了。那么为了让别人能开心的使用你的开源项目，当前需要有对应的说明文档吧。这是你会?直接写在readme开一个wiki这2种方式都可以。 现在你可以多一种方式了：为你的项目建一个GitHub Pages,通过网页的形式进行介绍第一步在你的开源项目下新建一个分支 (分支名：gh-pages)在你的分支里面放入你想要展示的页面(如果你的项目的master里面原本是有内容的，切的分支里面也会有对应的内容,因为这条分支后续是不会合并内容到主干的，所以可考虑把这些内容删除,方便后续的管理)这时你就可以通过 https://{你的用户名}.github.io/{你的项目仓库名(大小写要一致)}访问到你的项目了GitHub Pages了4. 注意事项GitHub Pages 网站是在网络上公开使用的，即使他们的库是私有的。如果你敏感的数据在你的Page库中，你可能需要在发布之前删除它5. 使用限制GitHub Pages源库建议限制在1GB内发布的GitHub Pages网站体积最大不能超过1GB,(还有每个月限制100000的访问量,但是从官网来看的话，这个限制应该是没有了)GitHub Page网站带宽限制是100GbGitHub Pages页面网站每小时最多有10次构建如果你超过了这些使用配额，Github官方将不会提供给你的网站提供服务，或者你可能会受到一个有礼貌的邮件，它是来自GitHub Support的建议策略，目的是降低你的网站对GitHub服务器的影响。建议其中包括迁移到一个不同的主机服务以便更加满足你的需求。6.禁止事项GitHub的服务条款禁止的或非法的内容或活动暴力或威胁性的内容或活动过多的自动化批量活动(例如，垃圾邮件)危害github用户或github服务的活动快速致富计划,也就是赌博等活动色情内容歪曲你的身份或网站目的的内容","path":"2019/08/01/GitHubPages介绍/","date":"08-01","excerpt":"","tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://lcn29.github.io/tags/GitHub/"}]}]}